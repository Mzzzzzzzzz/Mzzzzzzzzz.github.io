{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Mzsu","url":"https://Mzzzzzzzzz.github.io","root":"/"},"pages":[],"posts":[{"title":"LeetCode-移除元素","slug":"LeetCode-移除元素","date":"2021-01-30T05:22:58.000Z","updated":"2021-06-02T06:02:46.971Z","comments":true,"path":"2021/01/30/LeetCode-移除元素/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/30/LeetCode-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"##题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 123给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。","text":"##题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 123给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 ##解题1.对整个数组进行一次快速排序中的partition操作即可, 将数组分为等于val和不等于val的两部分2.设定[0,l]区间所有元素均不等于val,[l+1,i)区间元素等于val, l初始化化为-1, i初始化为0, 初始状态两个条件都满足设定3.遍历数组, 在遍历的过程中保持[0,l],[l+1,i)两个区间的特性 123456789101112131415161718192021class Solution &#123; public int removeElement(int[] nums, int val) &#123; // 其实就是根据快速排序的方式进行一次partition操作即可, 只是把元素分为不等于val和等于val的两部分 // 设定[0,l]区间所有元素均不等于val,[l+1,i)区间元素等于val, l初始化化为-1, i初始化为0, 初始状态两个条件都满足设定 // 遍历数组,进行partition操作 int l = -1; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != val)&#123; // i==l+1时不需要交换位置,只需要l++即可, 否则l+1和i交换位置保障[0,l],[l+1,i)两个区间的特性 if(i != l + 1)&#123; int temp = nums[l + 1]; nums[l + 1] = nums[i]; nums[i] = temp; &#125; l++; &#125; &#125; return l + 1; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-删除排序数组中的重复项","slug":"LeetCode-删除排序数组中的重复项","date":"2021-01-29T05:28:47.000Z","updated":"2021-06-02T06:02:46.970Z","comments":true,"path":"2021/01/29/LeetCode-删除排序数组中的重复项/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/29/LeetCode-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"##题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例1 : 123给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例2 : 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。","text":"##题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例1 : 123给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例2 : 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 ##解题定义两个变量分别记录不重复的元素位置, 和要遍历的元素位置, 如果不是重复元素就依次移动即可 123456789101112131415class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length &lt; 2) return nums.length; // [0...i]区间不包含重复元素, nums[i] == nums[j] int i = 0, j = 1; for(; j &lt; nums.length; j++)&#123; if(nums[j] != nums[i])&#123; nums[i + 1] = nums[j]; i++; &#125; &#125; return i + 1; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-k个一组翻转链表","slug":"LeetCode-k个一组翻转链表","date":"2021-01-28T05:44:00.000Z","updated":"2021-06-02T06:02:46.969Z","comments":true,"path":"2021/01/28/LeetCode-k个一组翻转链表/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/28/LeetCode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"##题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。","text":"##题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 ##解题1.使用递归算法2.每k个一组进行翻转, 同时将翻转后的最后一个节点指向下一组k个的头结点3.翻转之前需要先校验一次是否有k个节点, 是否需要进行翻转4.递归方法返回翻转后的头结点 123456789101112131415161718192021222324252627282930class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (k &lt; 2) &#123; return head; &#125; return reverse(head, k); &#125; private ListNode reverse(ListNode head, int k) &#123; ListNode cur = head; for (int i = 0; i &lt; k; i++) &#123; if (cur == null) &#123; return head; &#125; else &#123; cur = cur.next; &#125; &#125; ListNode nextReverse = cur; ListNode pre = null; cur = head; ListNode next; for (int i = 0; i &lt; k; i++) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; head.next = reverse(nextReverse, k); return pre; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-两两交换链表中的节点","slug":"LeetCode-两两交换链表中的节点","date":"2021-01-27T05:51:19.000Z","updated":"2021-06-02T06:02:46.967Z","comments":true,"path":"2021/01/27/LeetCode-两两交换链表中的节点/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/27/LeetCode-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"##题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。","text":"##题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 ##解题设置两个指针, 当前节点cur和下一个节点next, 每次交换cur和next即可 1234567891011121314151617181920212223242526class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode dummyHead = new ListNode(0); ListNode pre = dummyHead; // 每次cur和next交换位置 ListNode cur = head; ListNode next = head.next; while (cur != null &amp;&amp; next != null) &#123; // 交换cur 和next cur.next = next.next; next.next = cur; pre.next = next; // 移动pre, cur, next pre = cur; cur = cur.next; if (cur == null)&#123; break; &#125; next = cur.next; &#125; return dummyHead.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-四数之和","slug":"LeetCode-四数之和","date":"2021-01-26T05:33:08.000Z","updated":"2021-06-02T06:02:46.966Z","comments":true,"path":"2021/01/26/LeetCode-四数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/26/LeetCode-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"##题目给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例： 1234567给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]","text":"##题目给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例： 1234567给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] ##解题先排序后计算, 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) &#123; return res; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; if (nums[i] * 4 &gt; target) &#123; break; &#125; if (nums[i] + 3 * nums[nums.length - 1] &lt; target) &#123; continue; &#125; for (int j = i + 1; j &lt; nums.length - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; if (nums[j] * 3 &gt; target - nums[i]) &#123; break; &#125; if (nums[j] + 2 * nums[nums.length - 1] &lt; target - nums[i]) &#123; continue; &#125; int begin = j + 1; int end = nums.length - 1; while (begin &lt; end) &#123; int sum = nums[i] + nums[j] + nums[begin] + nums[end]; if (sum == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[begin], nums[end])); while (begin &lt; end &amp;&amp; nums[begin] == nums[begin + 1]) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; nums[end] == nums[end - 1]) &#123; end--; &#125; begin++; end--; &#125; else if (sum &lt; target) &#123; begin++; &#125; else &#123; end--; &#125; &#125; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-电话号码的字母组合","slug":"LeetCode-电话号码的字母组合","date":"2021-01-25T05:40:12.000Z","updated":"2021-06-02T05:51:05.180Z","comments":true,"path":"2021/01/25/LeetCode-电话号码的字母组合/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/25/LeetCode-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"##题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。","text":"##题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 ##解题字典 + 递归 + 回溯 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; private static char[][] NUM_CHAR = new char[][]&#123; null, null, &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;, &#123;&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;, &#123;&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;&#125;, &#123;&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;&#125;, &#123;&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;&#125;, &#123;&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;&#125;, &#123;&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;&#125;, &#123;&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125; &#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || &quot;&quot;.equals(digits)) &#123; return result; &#125; letterCombinations(digits, 0, &quot;&quot;); return result; &#125; private void letterCombinations(String digits, int index, String temp)&#123; if (index &gt; digits.length()) &#123; return; &#125; char[] chars = NUM_CHAR[Integer.parseInt(digits.substring(index, index + 1))]; if (index == digits.length() - 1) &#123; for (char aChar : chars) &#123; result.add(temp + aChar); &#125; &#125; else &#123; for (char aChar : chars) &#123; letterCombinations(digits, index + 1, temp + aChar); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-最接近的三数之和","slug":"LeetCode-最接近的三数之和","date":"2021-01-24T05:46:55.000Z","updated":"2021-06-02T05:51:35.926Z","comments":true,"path":"2021/01/24/LeetCode-最接近的三数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/24/LeetCode-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"##题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 12例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).","text":"##题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 12例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). ##解题先排序, 后计算,双指针, 滑动窗口 123456789101112131415161718192021222324252627class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; // 排序 Arrays.sort(nums); int closestNum = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int l = i + 1, r = nums.length - 1; while (l &lt; r)&#123; int threeSum = nums[l] + nums[r] + nums[i]; if (Math.abs(threeSum - target) &lt; Math.abs(closestNum - target)) &#123; closestNum = threeSum; &#125; if (threeSum &gt; target) &#123; r--; &#125; else if (threeSum &lt; target) &#123; l++; &#125; else &#123; return target; &#125; &#125; &#125; return closestNum; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-三数之和","slug":"LeetCode-三数之和","date":"2021-01-24T05:45:44.000Z","updated":"2021-06-02T06:02:46.964Z","comments":true,"path":"2021/01/24/LeetCode-三数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/24/LeetCode-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"##题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： 12345[[-1, 0, 1],[-1, -1, 2]]","text":"##题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： 12345[[-1, 0, 1],[-1, -1, 2]] ##解题 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; // 跳过可能重复的答案 int l = i + 1, r = nums.length - 1, sum = 0 - nums[i]; while (l &lt; r) &#123; if (nums[l] + nums[r] == sum) &#123; ls.add(Arrays.asList(nums[i], nums[l], nums[r])); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) &#123; l++; &#125; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) &#123; r--; &#125; l++; r--; &#125; else if (nums[l] + nums[r] &lt; sum) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) &#123; l++; // 跳过重复值 &#125; l++; &#125; else &#123; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) &#123; r--; &#125; r--; &#125; &#125; &#125; &#125; return ls; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-盛最多水的容器","slug":"LeetCode-盛最多水的容器","date":"2021-01-23T05:43:16.000Z","updated":"2021-06-02T05:51:40.616Z","comments":true,"path":"2021/01/23/LeetCode-盛最多水的容器/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/23/LeetCode-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"##题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例 12输入: [1,8,6,2,5,4,8,3,7]输出: 49","text":"##题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 ##解题方法一 : 暴力破解, 双层循环, 可能会超时, 时间复杂度O(n²)方法二 : 对撞指针, 代码如下 12345678910111213141516class Solution &#123; public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while(left &lt; right)&#123; if(height[left] &lt; height[right])&#123; maxArea = Math.max(maxArea, height[left] * (right - left)); left++; &#125; else &#123; maxArea = Math.max(maxArea, height[right] * (right - left)); right--; &#125; &#125; return maxArea; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-无重复字符的最长子串","slug":"LeetCode-无重复字符的最长子串","date":"2021-01-22T13:32:42.000Z","updated":"2021-06-02T05:47:22.563Z","comments":true,"path":"2021/01/22/LeetCode-无重复字符的最长子串/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/22/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"##题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 123输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 123输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。","text":"##题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 123输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 123输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。 ##方法使用滑动窗口解答, 判断字符是不是重复, 使用字符数组来判断 设定l,r两个指针, 首先移动指针r直到出现重复字符,这个时候只可能有一个字符重复, 然后再移动字符l, 如果已经不包含重复字符了, 如果移除的字符是已经出现过的字符, 则表示此时[l…r]之间已经没有重复字符了 重复上面整个步骤, 完成整改遍历过程即可, 遍历过程中记录r - l + 1的最大值, 具体代码如下:123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; char[] freq = new char[256]; int l = 0, r = -1; int max = 0; while (l &lt; s.length())&#123; if (r == s.length() - 1)&#123; break; &#125; if (freq[s.charAt(r + 1)] == 0)&#123; freq[s.charAt(r + 1)]++; r++; max = Math.max(max, r - l + 1); &#125; else &#123; freq[s.charAt(l)]--; l++; &#125; &#125; return max; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-两数相加","slug":"LeetCode-两数相加","date":"2021-01-21T13:28:42.000Z","updated":"2021-06-02T06:02:46.965Z","comments":true,"path":"2021/01/21/LeetCode-两数相加/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/21/LeetCode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"##题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","text":"##题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 方法：把每一位相加, 记录进位, 代码如下 1234567891011121314151617181920212223242526class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode list1 = l1, list2 = l2, cur = dummyHead; int carry = 0; int sum = 0; while (list1 != null || list2 != null )&#123; sum = carry; if (list1 != null) &#123; sum += list1.val; list1 = list1.next; &#125; if (list2 != null) &#123; sum += list2.val; list2 = list2.next; &#125; carry = sum / 10; cur.next = new ListNode(sum % 10); cur = cur.next; &#125; if (carry == 1) &#123; cur.next = new ListNode(1); &#125; return dummyHead.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-两数之和","slug":"LeetCode-两数之和","date":"2021-01-20T13:30:29.000Z","updated":"2021-06-02T06:02:46.963Z","comments":true,"path":"2021/01/20/LeetCode-两数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/20/LeetCode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"##题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]","text":"##题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法1：直接每次从头到尾比较 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] a = new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; a[0] = i; a[1] = j; //return new int[] &#123;i,j&#125;; &#125; &#125; &#125; return a; &#125;&#125; 方法2：两次for循环（两遍hashmap） 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] b = new int[2]; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; map.put(nums[i],i); &#125; for(int j=0;j&lt;nums.length;j++)&#123; int a = target - nums[j]; if(map.containsKey(a) &amp;&amp; j!=map.get(a))&#123; b[0] = j; b[1] = map.get(a); return b; //return new int[] &#123;j,map.get(a)&#125;; &#125; &#125; return b; &#125;&#125; 方法3：一次for循环（一次hashmap） 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; return new int[] &#123;map.get(nums[i]),i&#125;; &#125; map.put(target-nums[i],i); &#125; return new int[]&#123;1,1,1&#125;; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"Hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。","slug":"Hexo添加各种功能","date":"2021-01-18T05:17:49.000Z","updated":"2021-06-02T05:30:15.141Z","comments":true,"path":"2021/01/18/Hexo添加各种功能/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/18/Hexo%E6%B7%BB%E5%8A%A0%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD/","excerpt":"hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。 本文参考了: visugar.com这里面说的很详细了。 ##1. SEO优化推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。 1SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 ###百度seo刚建站的时候是没有搜索引擎收录我们的网站的。可以在搜索引擎中输入’site:&lt;域名&gt;’来查看一下。####1. 登录百度站长平台添加网站登录百度站长平台，在站点管理中添加你自己的网站。","text":"hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。 本文参考了: visugar.com这里面说的很详细了。 ##1. SEO优化推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。 1SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 ###百度seo刚建站的时候是没有搜索引擎收录我们的网站的。可以在搜索引擎中输入’site:&lt;域名&gt;’来查看一下。####1. 登录百度站长平台添加网站登录百度站长平台，在站点管理中添加你自己的网站。 验证网站有三种方式：文件验证、HTML标签验证、CNAME验证。 第三种方式最简单，只要将它提供给你的那个xxxxx使用CNAME解析到xxx.baidu.com就可以了。也就是登录你的阿里云，把这个解析填进去就OK了。 ####2. 提交链接我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎 12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 这时候你需要在你的根目录下’config.xml’中看看url有没有改成你自己的;重新部署后，就可以在public文件夹下看到生成的sitemap.xml和baidusitemap.xml了。 然后就可以向百度提交你的站点地图了。 这里建议使用自动提交。自动提交又分为三种：主动推送、自动推送、sitemap。 可以三个一起提交不要紧，我选择的是后两种。 自动推送:把百度生成的自动推送代码，放在主题文件/layout/common/head.ejs的适当位置，然后验证一下就可以了。 sitemap:把两个sitemap地址，提交上去，看到状态正常就OK了。ps: 百度收录比较慢，慢慢等个十天半个月再去’site:&lt;域名&gt;’看看有没有被收录。 ###google的SEO流程一样，google更简单，而且收录更快，进入google站点地图，提交网站和sitemap.xml，就可以了。 如果你这个域名在google这里出了问题，那你就提交 yourname.github.io，这个链接，效果是一样的。 不出意外的话一天内google就能收录你的网站了。 其他的搜索，如搜狗搜索，360搜索，流程是一样的，这里就不再赘述。 ##2. 评论系统评论系统有很多，但是很多都是墙外的用不了，之前说过这个valine好像集成在hueman和next主题里面了，但是我还没有研究过，我看的是visugar这个博主用的来比力评论系统，感觉也还不错。来比力官网，注册好后，点击管理页面，在代码管理中找到安装代码： 获取安装代码后，在主题的comment下新建一个文件放入刚刚那段代码，再找到article文件，找到如下代码，若没有则直接在footer后面添加即可。livebe即为刚刚所创文件名称。 1&lt;%- partial(&#x27;comment/livebe&#x27;) %&gt; 然后可以自己设置一些东西：还可以设置评论提醒，这样别人评论你的时候就可以及时知道了。 ##3. 添加百度统计百度统计可以在后台上看到你网站的访问数，浏览量，浏览链接分布等很重要的信息。所以添加百度统计能更有效的让你掌握你的网站情况。 百度统计，注册一下，这里的账号好像和百度账号不是一起的。照样把代码复制到head.ejs文件中，然后再进行一下安装检查，半小时左右就可以在百度统计里面看到自己的网站信息了。 ##4. 文章阅读量统计leanCloudleanCloud，进去后注册一下，进入后创建一个应用：在存储中创建Class，命名为Counter,然后在设置页面看到你的应用Key，在主题的配置文件中： 1234leancloud_visitors: enable: true app_id: 你的id app_key: 你的key 在article.ejs中适当的位置添加如下，这要看你让文章的阅读量统计显示在哪个地方了， 1阅读数量:&lt;span id=&quot;&lt;%= url_for(post.path) %&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&lt;%- post.title %&gt;&quot;&gt;&lt;/s&gt; 然后在footer.ejs的最后，添加： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script src=&quot;//cdn1.lncld.net/static/js/2.5.0/av-min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var APP_ID = &#x27;你的app id&#x27;; var APP_KEY = &#x27;你的app key&#x27;; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); // 显示次数 function showTime(Counter) &#123; var query = new AV.Query(&quot;Counter&quot;); if($(&quot;.leancloud_visitors&quot;).length &gt; 0)&#123; var url = $(&quot;.leancloud_visitors&quot;).attr(&#x27;id&#x27;).trim(); // where field query.equalTo(&quot;words&quot;, url); // count query.count().then(function (number) &#123; // There are number instances of MyClass where words equals url. $(document.getElementById(url)).text(number? number : &#x27;--&#x27;); &#125;, function (error) &#123; // error is an instance of AVError. &#125;); &#125; &#125; // 追加pv function addCount(Counter) &#123; var url = $(&quot;.leancloud_visitors&quot;).length &gt; 0 ? $(&quot;.leancloud_visitors&quot;).attr(&#x27;id&#x27;).trim() : &#x27;icafebolger.com&#x27;; var Counter = AV.Object.extend(&quot;Counter&quot;); var query = new Counter; query.save(&#123; words: url &#125;).then(function (object) &#123; &#125;) &#125; $(function () &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); addCount(Counter); showTime(Counter); &#125;);&lt;/script&gt; 重新部署后就可以了。 ##5. 引入不蒜子访问量和访问人次统计不蒜子的添加非常非常方便，不蒜子 在footer.ejs中的合适位置，看你要显示在哪个地方，添加： 1234&lt;!--这一段是不蒜子的访问量统计代码--&gt;&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp; &lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 就可以了。","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo博客配置RSS插件","slug":"Hexo博客配置RSS插件","date":"2021-01-17T07:49:21.000Z","updated":"2021-06-02T05:30:15.139Z","comments":true,"path":"2021/01/17/Hexo博客配置RSS插件/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/17/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AERSS%E6%8F%92%E4%BB%B6/","excerpt":"1、安装rss插件 在站点根目录下安装 1npm install hexo-generator-feed","text":"1、安装rss插件 在站点根目录下安装 1npm install hexo-generator-feed 2、配置_config.yml文件，启用插件12345678# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 3、在hexo-theme-yilia-plus主题添加RSS订阅配置(可以跳过此步骤) theme-yilia-plus 12# RSS订阅rss: /atom.xml 4、生成RSS订阅文件1hexo g","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mzzzzzzzzz.github.io/tags/Hexo/"}]},{"title":"Hexo博客添加helper-live2d动态模型插件","slug":"Hexo博客添加helper-live2d动态模型插件","date":"2021-01-16T08:35:44.000Z","updated":"2021-06-02T05:30:15.137Z","comments":true,"path":"2021/01/16/Hexo博客添加helper-live2d动态模型插件/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/16/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0helper-live2d%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%8F%92%E4%BB%B6/","excerpt":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 插件的github地址hexo-helper-live2d live2d模型仓库 必须有Node环境 ➡️ Linux下安装node和npm","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 插件的github地址hexo-helper-live2d live2d模型仓库 必须有Node环境 ➡️ Linux下安装node和npm 1、安装模块&#160;&#160;&#160;&#160;在hexo根目录执行命令 1# npm install --save hexo-helper-live2d 2、下载模型&#160;&#160;&#160;&#160;作者各种模型包展示 ➡️ hexo live2d插件 2.0 ! live2d模型仓库 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 使用npm install &#123;packagename&#125;安装模型 12---笔者使用的模型# npm install live2d-widget-model-nico 3、详细配置在Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.参阅 live2d-widget.js API 博主配置文件示例12345678910111213141516171819202122232425262728293031# Live2D## https://github.com/EYHN/hexo-helper-live2d## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: enable: true #enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-hibiki # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 145 height: 315 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo编译文档时JS或HTML混乱解决方案","slug":"Hexo编译文档时JS或HTML混乱解决方案","date":"2021-01-16T03:26:51.000Z","updated":"2021-06-02T05:30:15.140Z","comments":true,"path":"2021/01/16/Hexo编译文档时JS或HTML混乱解决方案/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/16/Hexo%E7%BC%96%E8%AF%91%E6%96%87%E6%A1%A3%E6%97%B6JS%E6%88%96HTML%E6%B7%B7%E4%B9%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"原因 之前为在 GitHub 博客上写自己的 html 网页，在 hexo 根目录下的 source 文件夹中放了自己的 js 文件，每次 hexo g 后，pubic 文件夹中的 js 文件就混乱了，与自己实际 js 不一致。 解决方案(跳过 hexo 渲染) Hexo 3.0 以上支持修改 Hexo 主目录下的 config.yml 配置文件中的 skip_render 参数。","text":"原因 之前为在 GitHub 博客上写自己的 html 网页，在 hexo 根目录下的 source 文件夹中放了自己的 js 文件，每次 hexo g 后，pubic 文件夹中的 js 文件就混乱了，与自己实际 js 不一致。 解决方案(跳过 hexo 渲染) Hexo 3.0 以上支持修改 Hexo 主目录下的 config.yml 配置文件中的 skip_render 参数。 1234567891011skip_render: &quot;test.html&quot; # source 文件夹下指定文件skip_render: test/* # 单个文件夹下全部文件skip_render: test/*.md # 单个文件夹下指定类型文件skip_render: test/** # 单个文件夹下全部文件及子文件skip_render: # 多个文件夹以及其他情况 - test/* - test/*.html 博主自己的配置如下 1234567891011121314# 跳过 hexo 渲染skip_render: - anires/** - assets/** - gitment/** - baidu_sitepush/** - canvas_nest/** - docs/** - &#x27;baidu_verify_QzGNSJ7F59.html&#x27; - &#x27;*.html&#x27; - &#x27;*.js&#x27; - README.md - &#x27;*.sh&#x27; - &#x27;*.txt&#x27; 注：若修改配置后不见效果，先执行 hexo clean 后再执行 hexo g 重新编译","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"关于npm install失败的解决方法","slug":"关于npm-install失败的解决方法","date":"2021-01-16T01:33:15.000Z","updated":"2021-06-02T05:12:15.388Z","comments":true,"path":"2021/01/16/关于npm-install失败的解决方法/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/16/%E5%85%B3%E4%BA%8Enpm-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"可以尝试以下解决方案 1.授权执行1sudo npm install 2.运行高权限用户1sudo npm install --unsafe-perm","text":"可以尝试以下解决方案 1.授权执行1sudo npm install 2.运行高权限用户1sudo npm install --unsafe-perm 3.安装某个模块1sudo npm i 模块名 --unsafe-perms 4.清除代理1npm config set proxy false 5.清除缓存1npm cache clean","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo更换主题","slug":"hexo更换主题","date":"2021-01-15T09:23:00.000Z","updated":"2021-06-02T05:10:03.012Z","comments":true,"path":"2021/01/15/hexo更换主题/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/15/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/","excerpt":"hexo更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里这里有200多个主题可以选。不过最受欢迎的就是那么几个，比如NexT主题，非常的简洁好看，大多数人都选择这个，关于这个的教程也比较多。不过我选择的是yilias-plus这个主题.不管怎么样，至少是符合我个人的审美。","text":"hexo更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里这里有200多个主题可以选。不过最受欢迎的就是那么几个，比如NexT主题，非常的简洁好看，大多数人都选择这个，关于这个的教程也比较多。不过我选择的是yilias-plus这个主题.不管怎么样，至少是符合我个人的审美。 使用yilias-plus1、安装12cd ./themes/git clone --depth=1 https://github.com/JoeyBling/hexo-theme-yilia-plus.git ./yilia-plus 2、配置修改hexo根目录下的 ‘config.yml’ -&gt; ‘theme: yilia-plus’ 3、更新12cd themes/yilia-plusgit pull 4、配置主题配置文件在主目录下的’config.yml’，请根据自己需要修改使用。完整配置Demo例子，可以参考yilia-plus博客备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283# Header-菜单menu: 主页: / 技术笔记: https://zhousiwei.gitee.io/ibooks/ 随笔: /tags/随笔/# subNav-子导航subNav: github: &quot;#&quot; gitee: &quot;#&quot; # 码云 jianshu: &quot;#&quot; #简书 cnblog: &quot;#&quot; #blog: &quot;#&quot; #csdn: &quot;#&quot; #rss: &quot;#&quot; #zhihu: &quot;#&quot; #qq: &quot;img/2434387555.jpg&quot; #weixin: &quot;img/weixin_.png&quot; #weibo: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:zhousiwei0911@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;# 悬停预览图片效果hover_effect: ## `global` 0: Set separately, 1: Enable global 2: Close global ## `global` 0: 分开设置, 1: 全局启用, 2: 全局关闭 global: 2 # SubNav-导航 subNav: true# RSS订阅(关于如何配置启用:https://www.jianshu.com/p/2aaac7a19736)rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 / 设为 /blog/。root: /# Content# 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &#x27;展开全文&#x27;# 数学公式mathjax: false# Open link in a new tab | 是否在新窗口打开链接open_in_new: article: true # 文章链接 menu: true # 导航菜单 subNav: true # 子菜单# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &#x27;谢谢你请我吃糖果&#x27;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/weixin.png# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &#x27;目录，不存在的…&#x27;# 是否有快速回到顶部的按钮top: true# Miscellaneous# 百度统计baidu_analytics: &#x27;&#x27;google_analytics: &#x27;&#x27;# 网站图标favicon: /favicon.ico# 你的头像urlavatar: /img/head.jpg# 是否开启分享share_jia: true# 评论：1、畅言；2、Disqus；3、Gitment；4、Giteement# 不需要使用某项，直接设置值为false，或注释掉# 具体请参考wiki：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki# 1、畅言changyan_appid: falsechangyan_conf: false# 2、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia-plus的disqus: false# 3、Gitment----基于GitHub的评论系统(关闭请设置gitment_owner为false)# 关于如何集成:https://www.jianshu.com/p/ac7658cc912fgitment_owner: false #你的 GitHub ID# 是否使用官方js(false可以提升访问速度，本地修改过一部分的js，官方js可能会出现服务器不稳定，不太建议使用)gitment_remote: falsegitment_repo: &#x27;&#x27; #存储评论的 repo name(需要在Github创建)gitment_oauth: client_id: &#x27;&#x27; #client ID client_secret: &#x27;&#x27; #client secret# 4、Giteement----【国内用户建议使用这个，相对比较快】# 关于如何集成:https://www.jianshu.com/p/f5c4633524c7# 基于码云的评论系统(https://gitee.com/zhousiwei/giteement)giteement: enable: false # 是否启用码云评论系统 # 是否使用官方js(false可以提升访问速度) remote: false redirect_uri: &#x27;&#x27; # 应用回调地址(请和配置的第三方应用保持一致) # 不能更改(网上开源项目`https://github.com/Rob--W/cors-anywhere`作者提供的专门用来跨域服务器的配置) oauth_uri: https://cors-anywhere.herokuapp.com/https://gitee.com/oauth/token giteeID: &#x27;&#x27; # 你的码云账号英文名 # 存储评论的 repo name(需要在码云仓库创建公开仓库) repo: &#x27;&#x27; gitment_oauth: client_id: &#x27;&#x27; #client ID client_secret: &#x27;&#x27; #client secret# 访问量统计功能(不蒜子)busuanzi: enable: true site_visit: true # 站点访问量显示 article_visit: true # 文章访问量显示# 网易云音乐插件music: enable: false # 播放器尺寸类型(1：长尺寸、2：短尺寸) type: 2 #id: 1332647902 # 网易云分享的音乐ID(更换音乐请更改此配置项) autoPlay: true # 是否开启自动播放 # 提示文本(关闭请设置为false) text: &#x27;这似乎是首纯音乐，请尽情的欣赏它吧！&#x27;# 页面点击小红心clickLove: # (关闭请设置为false) enable: true# GitHub Ribbons(https://github.blog/2008-12-19-github-ribbons/)github: # (关闭请设置为false) url: https://github.com/JoeyBling/hexo-theme-yilia-plus# 页脚 Litten(此配置项已弃用)# 帮助我们让更多人可以更方便使用Hexo，请尽量不要修改此主题配置pageFooter: litten: GitHub:&lt;a href=&quot;https://github.com/JoeyBling/hexo-theme-yilia-plus&quot; target=&quot;_blank&quot;&gt;hexo-theme-yilia-plus&lt;/a&gt;# 开启百度站长平台自动推送(https://ziyuan.baidu.com/linksubmit/index)baidu_push: false# 版权声明# 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明copyright_type: 2# 网站成立年份(默认为 2018，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)since: 2018# Progress Bar | 页面加载进度条# Demo: http://github.hubspot.com/pace/docs/welcome/# type: barber-shop|big-counter|bounce|center-atom|center-circle|# center-radar|center-simple|corner-indicator|flash|flat-top|# loading-bar|mac-osx|minimal# color: black|blue|green|orange|pink|purple|red|silver|white|yellow|progressBar: enable: false type: &#x27;minimal&#x27; # Keep Quotes | 保留引号避免出错(某些type会导致样式重叠排版错误) color: blue# Apple Touch icon 苹果图标(关闭请设置为false)apple_touch_icon: &#x27;/apple-touch-icon-180x180.png&#x27;# Tab Title Change | 标签页标题切换tab_title_change: enable: true left_tab_title: &#x27;(つェ⊂) 我藏好了哦~ &#x27; return_tab_title: &#x27;(*´∇｀*) 被你发现啦~ &#x27;# https://github.com/willin/hexo-wordcount# 是否开启字数统计(关闭请设置enable为false)# 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计word_count: enable: true # 只在文章详情显示(不在首页显示) only_article_visit: true# 文字输入特效# https://github.com/disjukr/activate-power-modeactivate_power_mode: enable: true # 使输入模式丰富多彩 colorful: true # 是否开启摇动 shake: false# 飘雪特效# https://github.com/MlgmXyysd/snow.jssnow: false# 看板娘动态模型插件## https://github.com/JoeyBling/live2d-widget.jslive2d: # (关闭请设置为false) enable: false # 模型名称(取值请参考：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki/live2d%E6%A8%A1%E5%9E%8B%E5%8C%85%E5%B1%95%E7%A4%BA) model: hibiki display: position: right # 显示位置：left/right(default: &#x27;right&#x27;) width: 145 # 模型的长度(default: 150) height: 315 # 模型的高度(default: 300) hOffset: 50 # 水平偏移(default: 0) #vOffset: -20 # 垂直偏移(default: -20) mobile: show: false # 是否在移动设备上显示(default: true) scale: 0.6 # 移动设备上的缩放(default: 0.5) react: opacity: 0.8 # 模型透明度(default: 0.7)# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 # header: &#x27;#D3D1DC&#x27; header: &#x27;#4d4d4d&#x27; gif: # 是否启用左侧边栏动态图效果 enable: false # 自定义背景图路径(默认可以不设置，提供默认背景图) # path: /img/biubiubiu.gif # 右滑板块背景 slider: &#x27;linear-gradient(200deg,#a0cfe4,#e8c37e)&#x27;# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &#x27;所有文章&#x27; friends: &#x27;友链&#x27; aboutme: &#x27;关于我&#x27;# 友情链接friends: 技术笔记: #网站名称 #网站地址 url: https://zhousiwei.gitee.io/ibooks/ #网站图片(可忽略不写) img: https://zhousiwei.gitee.io/ibooks/favicon.ico #网站简介(可忽略不写) description: 记录工作和学习过程中的笔记：Java、前端开发、Hexo博客、聚合支付、Linux笔记、ElasticSearch、ELK日志分析 GitHub: url: https://github.com/JoeyBling 码云: url: https://gitee.com/zhousiwei 简书: url: https://www.jianshu.com/u/02cbf31a043a CSDN: url: https://blog.csdn.net/qq_30930805# 关于我aboutme: 主要涉及技术：&lt;br&gt;Java后端开发、聚合支付、&lt;br&gt;公众号开发、开源爱好者、Linux&lt;br&gt;&lt;br&gt;联系QQ:2434387555&lt;br&gt;&lt;br&gt;很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo的基本配置","slug":"hexo的基本配置","date":"2021-01-14T04:31:22.000Z","updated":"2021-06-02T05:10:03.013Z","comments":true,"path":"2021/01/14/hexo的基本配置/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/14/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","excerpt":"hexo的基本配置hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。","text":"hexo的基本配置hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。 其中，’description’主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。’author’参数用于主题显示文章的作者。 网址 参数 描述 url 网址 root 网站根目录 permalink 文章的永久链接格式 permalink_defaults 永久链接中各部分的默认值 在这里，你需要把’url’改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫’temp.md’，那么这个时候他自动生成的地址就是’http://yoursite.com/2021/01/14/temp&#39;。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找。 参数 描述 :year/:month/:day/:title/ 2013/07/14/hello-world :year-:month-:day-:title.html 2013-07-14-hello-world.html :category/:title foo/bar/hello-world 再往下翻，中间这些都默认就好了。 1234567theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] ‘theme’就是选择什么主题，也就是在’theme’这个文件夹下，在官网上有很多个主题，默认给你安装的是’lanscape’这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在’theme’文件夹下，再修改这个参数就可以了。 接下来这个’deploy’就是网站的部署的，’repo’就是仓库(Repository)的简写。’branch’选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 ‘—‘ 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 下是预先定义的参数，您可在模板中使用这些参数值并加以利用。| 参数 | 描述 || :—-: | :—-: || layout | 布局 || title | 标题 || date | 建立日期 || updated | 更新日期 || comments | 开启文章的评论功能 || tags | 标签（不适用于分页） || categories | 分类（不适用于分页） || permalink | 覆盖文章网址 | 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 ‘Foo, Bar’ 不等于 ‘Bar, Foo’；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games layout（布局)当你每一次使用代码 1hexo new paper 它其实默认使用的是’post’这个布局，也就是在’source’文件夹下的’post’里面。 Hexo 有三种默认布局：’post’、’page’ 和 ‘draft’，它们分别对应不同的路径，而您自定义的其他布局和 ‘post’ 相同，都将储存到 ‘source/posts’ 文件夹。| 布局 | 路径 || :—-: | :—-: || post | source/posts || page | source || draft | source/drafts |而new这个命令其实是： 1hexo new [layout] &lt;title&gt; 只不过这个layout默认是post罢了。 ###page如果你想另起一页，那么可以使用 1hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是’http://xxx.xxx/board&#39; ###draftdraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source/draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo搭建","slug":"hexo搭建","date":"2021-01-13T12:18:15.000Z","updated":"2021-06-02T05:09:57.475Z","comments":true,"path":"2021/01/13/hexo搭建/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/13/hexo%E6%90%AD%E5%BB%BA/","excerpt":"选择Hexo的原因现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。","text":"选择Hexo的原因现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用 git --version 来查看一下版本 2. 安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3. 安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init myblog 这个myblog可以自己取什么名字都行，然后 12cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件12hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。注册完登录后，在GitHub.com中看到一个New repository，新建仓库创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。点击create repository。5.生成SSH添加到GitHub回到你的git bash中，12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。可以用以下两条，检查一下你有没有输对12git config user.namegit config user.email 然后创建SSH,一路回车1ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。在gitbash中，查看是否成功1ssh -T git@github.com 6. 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。1npm install hexo-deployer-git --save 然后123hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写注意deploy时可能要你输入username和password。","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"},{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://mzzzzzzzzz.github.io/tags/Hexo/"}]}