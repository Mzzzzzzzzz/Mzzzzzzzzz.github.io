{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Mzsu","url":"https://Mzzzzzzzzz.github.io","root":"/"},"pages":[],"posts":[{"title":"Randla net","slug":"Randla net","date":"2021-05-21T11:30:42.000Z","updated":"2021-06-02T09:37:37.016Z","comments":true,"path":"2021/05/21/Randla net/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/05/21/Randla%20net/","excerpt":"Randla net针对目前点云分割存在速度慢、显存需求大的问题，该文提出以一种高效率学习的方法。从论文的结果来看，该文不仅在计算时间和计算资源上大幅缩减，分割效果也是达到甚至超过了SOTA。","text":"Randla net针对目前点云分割存在速度慢、显存需求大的问题，该文提出以一种高效率学习的方法。从论文的结果来看，该文不仅在计算时间和计算资源上大幅缩减，分割效果也是达到甚至超过了SOTA。 采样大规模点云处理的一个挑战在于如何快速且有效地进行采样，从而加速应用所需的时间和计算资源。针对这个问题，本文的一个贡献在于比对了现有方法的效率，结论是尽管最远点采样是最流行的作法，但是对于LiDAR数据，每一帧上万个点需要处理，随机采样是最适合的，速度快并且performance也不错。但是随机采样可能会丢失重要的点，所以作者提出Local Feature Aggregation。（这里偷个懒，用组会的ppt代替）这篇文章的核心就是让网络能够自己去学习点云的local feature。","categories":[],"tags":[{"name":"3D vision","slug":"3D-vision","permalink":"https://mzzzzzzzzz.github.io/tags/3D-vision/"}]},{"title":"Point Transformer","slug":"Point Transformer","date":"2021-05-14T11:18:14.000Z","updated":"2021-06-02T09:37:37.015Z","comments":true,"path":"2021/05/14/Point Transformer/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/05/14/Point%20Transformer/","excerpt":"Point Transformer创造了一个点云处理方式也就是题目的Point transformer，将nlp领域中的transformer引入了点云处理领域","text":"Point Transformer创造了一个点云处理方式也就是题目的Point transformer，将nlp领域中的transformer引入了点云处理领域 首先先回顾一下nlp中transformer的设计方式:自注意力self-attention是很常见的，如果是在nlp领域中就是一句话中某个词和其他词的关系的表示，如果是在点云领域前面几篇论文中也有，就是一组点中每个点与其他点的距离、位置等关系表示这里的Q是查询向量，K是键向量，V是值向量，这里三个向量都是原输入序列中每个词的词嵌入和各自的QKV权重矩阵相乘得到，目的就是为了模拟出三个向量。首先先是使用Q和K进行点积，这里的意思就是将查询向量（这里可以理解成为位置）和键向量（这里可以理解成为词对位置的重视程度）结合，得到的结果就是该单词有多重视句子中的位置，比如对于第一个单词来说，它对第一个位置的重视程度就是q1×kq，对第二个位置的就是q1×k2，然后使用softmax来表示每个单词对编码当前单词这个位置的贡献得到后点积上V也就是值向量，这里是在位置的基础上再希望它加上语义关系，比如对于第一个位置和第二个位置如果语义不接近，自然希望它的权重要变小总的来说就是对于每个单词来说，它所嵌入的向量结果需要包含了句子的位置信息和词之间的语义信息关系这里还加了一个multi-head的方法，其实就是设计了多个权重矩阵，就像设计了多个不同大小的卷积核来获得不同的attention，最后自然也是concat起来这就是核心的自注意力层 然后再来看point transformer先是简单的attention层设计这里的y是输出的feature，ϕ、ψ、α都是逐点特征变换的一种方式（比如mlp），δ是一个位置编码函数，ρ是正则化函数，简单来说，xi是点i的feature向量，先通过特征变换将点i和点j的特征得到，这里的β是关系函数，通过这个函数得到两个点特征之间的关系，也就是建立每个点特征之间的关系，然后加上位置编码函数δ，γ是映射函数，也就是映射到某一维度而用这里可以和前面进行类比在在这基础上就可以设计这里的重点，Point transformer层了这里大体上与上面类似，X(i)就是点i的邻域（常用KNN来得到），然后至于计算两点特征的关系这里采用的是向量的直接减法，映射函数γ由一个MLP组成，整体结构如图输入是(x,p)也就是每个点的位置信息，首先通过两个线性函数编码不同主次点的特征向量（也就是得到前面的key向量），再用一个MLP得到位置函数，也就是前面的查询向量），两者结合得到relation关系，然后再用一个线性函数得到它的值向量，将relation和值向量结合，也就是前面说的对于每个点既关注它的和其他点之间的语义关系，也关注它和其他点之间的位置关系，最后输出y作为点云处理结果接下来就是定义几个函数的具体计算方法首先是位置函数也就是计算查询向量的那个函数p就是各自点的三维坐标值，θ是一个MLP层，而前面的线性函数也就是ax+b的形式（就是linear层）定义完了transformer层，就可以定义一个block来作为集合输入是点集合x（拥有各自的三维点坐标等点特征），输出就是将每个点x的更新后的特征输出同样还设计了另外两种block分别有各自不同的功能，down的功能是根据需要减少点集的基数，简单来说就是减少点，而up就是根据两个不同数量的点来得到结合后的结果，常常使用在U型网络设计中（也就是当前层结果是结合了当前层的输入和之前某一层不同维度的输出而得到） 总结1.这里没有使用任何的卷积操作，使用attention机制代替了卷积2.通常positional encoding只加在计算权重的过程中，本文将其加在了Value这里而且实验证明这样可以提升性能。","categories":[],"tags":[{"name":"3D vision","slug":"3D-vision","permalink":"https://mzzzzzzzzz.github.io/tags/3D-vision/"}]},{"title":"PointNet++","slug":"PointNet++","date":"2021-05-08T04:56:34.000Z","updated":"2021-06-02T09:37:37.017Z","comments":true,"path":"2021/05/08/PointNet++/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/05/08/PointNet++/","excerpt":"解读:虽然这篇文章叫PointNet++，但和PointNet相比还是有很大的改进。文章非常核心的一点就是提出了多层次特征提取结构。具体来说就是先在输入点集中选择一些点作为中心点，然后围绕每个中心点选择周围的点组成一个区域，之后每个区域作为PointNet的一个输入样本，得到一组特征，这个特征就是这个区域的特征。之后中心点不变，扩大区域，把上一步得到的那些特征作为输入送入PointNet，以此类推，这个过程就是不断的提取局部特征，然后扩大局部范围，最后得到一组全局的特征，然后进行分类。文章中还提出了多尺度的方法解决样本不均匀的问题，这些方法对于分类的精度没有贡献，但在样本很稀疏的时候的确能让模型更有鲁棒性。","text":"解读:虽然这篇文章叫PointNet++，但和PointNet相比还是有很大的改进。文章非常核心的一点就是提出了多层次特征提取结构。具体来说就是先在输入点集中选择一些点作为中心点，然后围绕每个中心点选择周围的点组成一个区域，之后每个区域作为PointNet的一个输入样本，得到一组特征，这个特征就是这个区域的特征。之后中心点不变，扩大区域，把上一步得到的那些特征作为输入送入PointNet，以此类推，这个过程就是不断的提取局部特征，然后扩大局部范围，最后得到一组全局的特征，然后进行分类。文章中还提出了多尺度的方法解决样本不均匀的问题，这些方法对于分类的精度没有贡献，但在样本很稀疏的时候的确能让模型更有鲁棒性。 1. AbstractPointNet存在的一个缺点是无法获得局部特征，这使得它很难对复杂场景进行分析。在PointNet++中，作者通过两个主要的方法来进行改进，使得网络能更好的提取局部特征。第一，利用空间距离（metric space distances），使用PointNet对点集局部区域进行特征迭代提取，使其能够学到局部尺度越来越大的特征。第二，由于点集分布很多时候是不均匀的，如果默认是均匀的，会使得网络性能变差，所以作者提出了一种自适应密度的特征提取方法。通过以上两种方法，能够更高效的学习特征，也更有鲁棒性。 2. Introduction在PointNet++中，作者利用所在空间的距离度量将点集划分（partition）为有重叠的局部区域（可以理解为patch）。在此基础上，首先在小范围中从几何结构中提取局部特征（浅层特征），然后扩大范围，在这些局部特征的基础上提取更高层次的特征，知道提取到整个点集的全局特征。可以发现，这个过程和CNN网络的特征提取过程类似，首先提取低级别的特征，随着感受野的增大，提取的特征level越来越高。 PointNet++需要解决两个关键的问题：第一，如何将点集划分为不同的区域；第二，如何利用特征提取器获取不同区域的局部特征。这两个问题实际上是相关的，要想通过特征提取器来对不同的区域进行特征提取，需要每个分区具有相同的结构。这里同样可以类比CNN来理解，在CNN中，卷积块作为基本的特征提取器，对应的区域都是n * n的像素区域。而在3D点集当中，同样需要找到结构相同的子区域，和对应的区域特征提取器。在本文中，作者使用了PointNet作为特征提取器，另外一个问题就是如何来划分点集从而产生结构相同的区域。作者使用邻域球球来定义分区，或者也可以叫做patch，每个区域可以通过中心坐标和半径来确定。中心坐标的选取，作者使用了快速采样算法来完成（farthest point sampling (FPS) algorithm）。区域半径的选择是一个比较有挑战性的事情，因为输入点集是不均匀的，同时区域特征会存在重叠或被遗忘的情况。尽管在VGG当中提到，CNN使用小的卷积核效果比较好，但这是由于图像是网格化的，每个区域是非常规整的，如果再PointNet++使用小的半径，网络性能反而很差。这里可以从直观上想象一下，邻域球过小，可能意味着可能看不到足够完整的局部特征。这个过程也可是使用KNN实现。 3. 网络结构PointNet++是PointNet的延伸，在PointNet的基础上加入了多层次结构（hierarchical structure），使得网络能够在越来越大的区域上提供更高级别的特征。网络的每一组set abstraction layers主要包括3个部分：Sampling layer, Grouping layer and PointNet layer。 Sample layer：主要是对输入点进行采样，在这些点中选出若干个中心点（问题：怎么选，选多少个点？） Grouping layer：是利用上一步得到的中心点将点集划分成若干个区域； PointNet layer：是对上述得到的每个区域进行编码，变成特征向量。 每一组提取层的输入是N*(d + C)，其中N是输入点的数量，d是坐标维度，C是特征维度。输出是N’*(d + C’)，其中N’是输出点的数量，d是坐标维度不变，C’是新的特征维度。下面详细介绍每一层的作用及实现过程。 1). Sample layer使用farthest point sampling选择N’个点，至于为什么选择使用这种方法选择点，文中提到相比于随机采样，这种方法能更好的的覆盖整个点集。具体选择多少个中心点，数量怎么确定，是由人来指定的。 2). Grouping layer这一层使用Ball query方法生成N’个局部区域，根据论文中的意思，这里有两个变量 ，一个是每个区域中点的数量K，另一个是球的半径。这里半径应该是占主导的，会在某个半径的球内找点，上限是K。球的半径和每个区域中点的数量都是人指定的。这一步也可以使用KNN来进行，而且两者的对于结果的影响并不大。 3). PointNet layer这一层是PointNet，接受N’×K×(d+C)的输入。输出是N’×(d+C)。需要注意的是，在输入到网络之前，会把该区域中的点变成围绕中心点的相对坐标。作者提到，这样做能够获取点与点之间的关系（对这一点存疑，但感觉有限像Batch Norm？）。 4). 对于非均匀点云的处理方法点云不均匀时，每个子区域中如果在分区的时候使用相同的球半径，会导致有些稀疏区域采样点过小。这个地方插一点自己的想法，从一个角度来看，点云的疏密程度是不是可以看做样本属性的一部分？从这个意义上来讲这就不是一个需要克服的缺点。如果担心某些区域采样点过小，是否可以加一个阈值下限。 作者提到这个问题需要解决，并且提出了两个方法：Multi-scale grouping (MSG) and Multi-resolution grouping (MRG)。第一种多尺度分组（MSG），对于同一个中心点，如果使用3个不同尺度的话，就分别找围绕每个中心点画3个区域，每个区域的半径及里面的点的个数不同。对于同一个中心点来说，不同尺度的区域送入不同的PointNet进行特征提取，之后concat，作为这个中心点的特征。也就是说MSG实际上相当于并联了多个hierarchical structure，每个结构中心点数量一样，但是区域范围不同（可以理解成感受野？），PointNet的输入和输出尺寸也不同，然后几个不同尺度的结构在PointNet有一个Concat。 另一种是多分辨率分组（MRG)。MSG很明显会影响降低运算速度，所以提出了MRG，这种方法应该是对不同level的grouping做了一个concat，但是由于尺度不同，对于low level的先放入一个pointnet进行处理再和high level的进行concat。感觉和ResNet中的跳连接有点类似。在这部分，作者还提到了一种random input dropout（DP）的方法，就是在输入到点云之前，对点集进行随机的Dropout,比例使用了95%，也就是说进行95%的重新采样。某种程度有点像数据增强，也是提高模型的robustness。那这些方法效果怎么样呢，我们一起来看一下。 从论文中的这幅分类实验结果图可以看出来，多尺度（MSG,MRG)和单一尺度相比（SSG）对分类的准确率没有什么提升，有一个好处是如果点云很稀疏的话，使用MSG可以保持很好的robustness。对于robustness效果random input dropout（DP）其实贡献更大。","categories":[],"tags":[{"name":"3D vision","slug":"3D-vision","permalink":"https://mzzzzzzzzz.github.io/tags/3D-vision/"}]},{"title":"PointNet","slug":"PointNet","date":"2021-05-02T03:28:14.000Z","updated":"2021-06-02T09:16:21.344Z","comments":true,"path":"2021/05/02/PointNet/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/05/02/PointNet/","excerpt":"PointNetPointNet是斯坦福大学研究人员提出的一个点云处理网络，与先前工作的不同在于这一网络可以直接输入无序点云进行处理，而无序将数据处理成规则的3Dvoxel形式进行处理。输入点云顺序对于网络的输出结果没有影响，同时也可以处理旋转平移后的点云数据。点云是一种重要的几何数据形式。卷积网络通常需要规则的数据形式作为输入，但由于点云是非规则数据类型所以通常的做法大都先对点云进行规则化的处理，将空间划分成网格的体素voxel就是一种典型的做法。但这样的方式会造成有很多不必要的体积划分使得输入数据变得稀疏，同时会影响点云数据的不变性。","text":"PointNetPointNet是斯坦福大学研究人员提出的一个点云处理网络，与先前工作的不同在于这一网络可以直接输入无序点云进行处理，而无序将数据处理成规则的3Dvoxel形式进行处理。输入点云顺序对于网络的输出结果没有影响，同时也可以处理旋转平移后的点云数据。点云是一种重要的几何数据形式。卷积网络通常需要规则的数据形式作为输入，但由于点云是非规则数据类型所以通常的做法大都先对点云进行规则化的处理，将空间划分成网格的体素voxel就是一种典型的做法。但这样的方式会造成有很多不必要的体积划分使得输入数据变得稀疏，同时会影响点云数据的不变性。 PointNet从不同的角度出发来解决这一问题，考虑到点云数据的本质是一个点集，它具有一下特征： 无序性，点云是一个点集，没有固定的顺序； 与邻域点又相互作用，点云中的个体不是独立的，与周围的点具相关，具有局域特征； 刚体旋转、平移不变性，旋转和平移不会改变点云的分类、分割结果。PointNet的结构十分简单，它可以直接输出点云数据，随后得到分类分割的结果。模型对无序点云的每一个点进行独立的处理，由此来实现与输入顺序无关的点云处理。在网络中关键的结构是一个单对称函数最大池化（max pooling）。1模型通过学习选择出点云中感兴趣点/信息点，并将选择的原理编码到模型中，最后利用全连接层将学习到的特征合称为全局的描述子。 这一模型中输入点是独立的，研究人员同时增加了不依赖于数据的空间变化网络来处理刚体或仿射变换，在输入网络前对点云数据进行规范化(canonicalize)处理, 消除旋转等变换带来的影响。 1.处理点云通常的方法分为一下几类： 类别 方法1 方法2 方法3 方法4 点云特征 编码统计特性（不变性） 内蕴/外部特征 全局/局部特征 / 3D数据深度学习 Volumetric（稀疏+计算量大） Multiview多视角卷积（不易拓展） Special空间卷积 Featurebased基于特征的卷积(受制于表达能力) 无序数据的深度学习sort规范化 序列模型RNN 对称函数集成每点信息 / / 2.FrameworkPointNet 利用了对称函数——最大池化的方法来对点云中各点的信息进行融合。它的具体结构如下图所示，其中输入是3通道( x , y , z ) (x,y,z)(x,y,z)的点云数据, 输出是分类标签或者是分割结果。网络共分为6个部分： 输入变换——&gt;对齐输入点云（规范化canonical space） 点云处理——&gt;MLP处理点云（升维到64） 特征变换——&gt;对齐输入特征（规范化canonical space） 特征处理——&gt;MLP处理特征（升维到1024） 对称函数处理——&gt;全局特征（Max pooling） 感知机 其中第一部分的T − Net,T−Net是一个微型网络，用于生成一个仿射变换矩阵来对点云的旋转、平移等变化进行规范化处理。这个变换对齐网络是一个微型的PointNet，它输入原始点云数据，输出为一个3∗3的旋转矩阵. 同样的思路也可以用于对于特征空间的对齐.变换,唯一的不同在于输入编程了64维的特征，而输出则是64 ∗ 64的变换矩阵了. 第二部分则是对点云和特征进行处理的n个感知机，将n ∗ 3的点云输入后，对于每一个点都有一个64 ∗ 64的两层感知机来对点云进行处理，这里相当于利用MLP近似了一个通用的函数，将每个点的信息通过感知机进行学习和提取，随后利用最大池化层对信息进行融合生成全局特征. 1f(&#123;x_1,x_2,......,x_n&#125;)=g(h(x_1),h(x_2).....,h(x_n)) 其中h就相当于MLP感知机，而g就是起到对称函数作用的Max Pooling。在网络中mlp(64,64)和mlp(64,128,1024)都是复用的，是一个MLP的n份复制。最后，每一个输入的点都将得到1024维的描述，通过最大池化，将n-1024融合为1024维的特征来描述这一向量.在分类任务中，点云生成的1024维特征通过最后一个MLP来进行学习，其中k是最后一层的输出数量，代表分类的类别，每个类别会对应对于点云的分类得分。而在分割任务中，由于需要考虑局部特征，需要将n * 64局域特征和1024维的全局特征结合在一起进行融合，在每一个点的64维特征后接续1024全局特征：随后利用一个mlp(512,512,128)对n ∗ 1088维的特征维度进行学习，生成n ∗ 128 的向量，再利用(128,m)的感知机对最后的特征进行分类（分割问题其实是针对每一个点的分类问题），其中n对应n个点，而m对应的是点对应的m个分类得分。","categories":[],"tags":[{"name":"3D vision","slug":"3D-vision","permalink":"https://mzzzzzzzzz.github.io/tags/3D-vision/"}]},{"title":"Java中的线程是如何与Linux进行调用的","slug":"Java中的线程是如何与Linux进行调用的","date":"2021-03-17T02:39:46.000Z","updated":"2021-06-02T09:47:02.541Z","comments":true,"path":"2021/03/17/Java中的线程是如何与Linux进行调用的/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/03/17/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8ELinux%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8%E7%9A%84/","excerpt":"在Java基础中我们知道，一般要实现一个线程通常是有两种方法，当然这里没有算上使用callable等其他的实现方式。如果使用继承Thread或者实现runnable接口，那么便需要重写里面的run方法。","text":"在Java基础中我们知道，一般要实现一个线程通常是有两种方法，当然这里没有算上使用callable等其他的实现方式。如果使用继承Thread或者实现runnable接口，那么便需要重写里面的run方法。 123456789101112131415161718192021222324252627282930313233public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&#x27;s list of threads * and the group&#x27;s unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; private native void start0(); 可以从上面的源码可以看见，实际上thread在调用start方法时，其实还调用了一个start0的方法。而且这个start0的方法是个本地native方法。可以假设其实Java虚拟机就是调用这个start0的方法，开启了一个Linux的内核线程。这样的话就来做些实验： 先简单的写一个Java类TestThread： 123456789101112package test; public class TestThread&#123; static&#123; System.loadLibrary(&quot;TestThreadNative&quot;); &#125; public static void main(String[] args)&#123; TestThread testThread=new TestThread(); testThread.start0(); &#125; private native void start0();&#125; 这里的System.loadLibrary方法，这个方法就类似我们win电脑中dll,一个链接库。其实这个库就是就是为了完成下面start0函数的实现。而且这里要注意一点，这串字符确定后，需要在编译这个库时需要指定，所以请记住各个字符串。 接下来使用Javac函数来编译一下：就可以得到TestThread.class文件 然后使用Javah TestThread 注意使用这个命令是需要带类的全路径包名，否则会报错。我这里是 javah test.TestThread 。得到就是一个test_TestThread.h 通常这个文件是在和Java文件包的同一级目录下。把这个test_TestThread.h放进和TestThread.class一起省的节外生枝。下面是生成的test_TestThread.h的内容： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class test_TestThread */#ifndef _Included_test_TestThread#define _Included_test_TestThread#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: test_TestThread * Method: start0 * Signature: ()V */JNIEXPORT void JNICALL Java_test_TestThread_start0 (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 从上面可以看出，其实需要实现的就是其中的这个方法 1JNIEXPORT void JNICALL Java_test_TestThread_start(JNIEnv *, jobject); 此时已经得到了TestThread.class、test_TestThread.h，那么下一步，需要写一个C文件thread.c，这个C文件引入testThread.h这个头文件，在thread.c文件中，实现那个头文件中的start线程方法。在Linux中，创建一个线程需要用到pthread_create(&amp;pid,NULL,thread_entity,NULL);这个方法。 其中，第一个参数pid是线程的地址，第二个参数是线程属性，第三个参数方法是线程体，或者说是实现线程逻辑的函数指针，第四个参数是传入的参数； 下面贴出我在这定义的thread.c的内容： 123456789101112131415161718192021222324#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &quot;test_TestThread.h&quot;pthread_t pid;void* thread_entity(void* arg)&#123; while(1)&#123; usleep(100); printf(&quot;i am new thread\\n&quot;); &#125;&#125;JNIEXPORT void JNICALL Java_test_TestThread_start0(JNIEnv *env, jobject c1)&#123; pthread_create(&amp;pid,NULL,thread_entity,NULL); while(1)&#123; usleep(100); printf(&quot;i am main\\n&quot;); &#125;&#125;int main()&#123; return 0;&#125; 最后，把这部分逻辑，编译成在TestThread.java中的TestThreadNative.so文件 然后让TestThread.java文件进行加载。 123gcc -fPIC -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/linux/ -shared -o libTestThreadNative.so thread.c/usr/lib/jvm/java‐1.8.0‐openjdk/include //这个文件下有jni相关的文件 因为在test_TestThread.h中引入了 #include &lt;jni.h&gt;/usr/lib/jvm/java‐1.8.0‐openjdk/include/linux //在这个文件下 linux相关的依赖 现在离最后一步还差:把链接库加入到环境变量： 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/test 最后运行 Java com.TestThread 带包名运行即可总结：TestThread.java -&gt;TestThread.class-&gt;test_TestThread.h-&gt;thread.c-&gt;libTestThreadNative.so-&gt;添加so文件到libaray_path最后运行 java test.TestThread","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://mzzzzzzzzz.github.io/tags/java/"}]},{"title":"半边数据结构","slug":"半边数据结构","date":"2021-03-02T01:13:29.000Z","updated":"2021-06-02T09:16:21.347Z","comments":true,"path":"2021/03/02/半边数据结构/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/03/02/%E5%8D%8A%E8%BE%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"介绍表示多边形网格(polygon mesh)的一个常用方式就是使用共享的顶点列表和面的列表（里面包含面所含的顶点）。这样的表示方法在许多情况下都非常方便和高效，但是在某些特定的领域，反而会效率比较低。 举例来说，网格简化(mesh simplification)通常需要把一条边退化成一个顶点。这个操作需要删除与这条边邻接的面并且更新面中存储的与这条边相关的顶点数据。这种多边形“手术”需要我们了解网格的组成部分的邻接关系，例如面和顶点。虽然我们肯定可以用之前提及的网格表示方法来实现网格简化，但是代价会比较高。许多情况下需要遍历面或者点的列表，或者二者都有。在一个多边形网格上其他类型的的临近查询包括： 哪条边用到了这个点 哪条边用到这个点 哪个面临近这条边 哪条边临近这个面 哪个面临近这个面 为了使得这些类型的临近查询更加","text":"介绍表示多边形网格(polygon mesh)的一个常用方式就是使用共享的顶点列表和面的列表（里面包含面所含的顶点）。这样的表示方法在许多情况下都非常方便和高效，但是在某些特定的领域，反而会效率比较低。 举例来说，网格简化(mesh simplification)通常需要把一条边退化成一个顶点。这个操作需要删除与这条边邻接的面并且更新面中存储的与这条边相关的顶点数据。这种多边形“手术”需要我们了解网格的组成部分的邻接关系，例如面和顶点。虽然我们肯定可以用之前提及的网格表示方法来实现网格简化，但是代价会比较高。许多情况下需要遍历面或者点的列表，或者二者都有。在一个多边形网格上其他类型的的临近查询包括： 哪条边用到了这个点 哪条边用到这个点 哪个面临近这条边 哪条边临近这个面 哪个面临近这个面 为了使得这些类型的临近查询更加 为了使得这些类型的临近查询更加有效，发展出更加精细的边界表示方案（b-reps），更加明确地建模表示点、边和面，并且也临近信息也相应地储存进去了。这些表示类型中最常见的其中一种是“翼边数据结构”（winged-edge）。其中每条边包含了指向其两个顶点，两个邻接面的指针以及指向从其终点延伸出去的四条边的指针。这种结构可以让我们在常数时间内判断哪些点与面与该边连接，但是面对其他类型的查询，这种结构会带来更大的开销。 半边(half-edge)数据结构是一种略微复杂的边表示方法(b-reps)并且在其上做之前提到的所有操作都可以在常数时间完成。更优秀的是，即使包含了面、顶点和边的邻接信息，数据结构的大小是固定的（没有使用动态数组）且紧凑的。 这些特性是的半边数据结构成为了许多应用的最佳选择，但是其只能表示流形表面(manifold surfaces)，而在某些情况下被证明是不可用的（流形的数学定义指的是曲面上的每一点都有一个小邻域，小邻域有一个圆盘的拓扑结构。对于多边形网格来说，这意味着每条边是且只能是两个面的边，T-型接合（t-junctions）和内部多边形（internal polygons）和网格中的空缺时，不能使用半边结构。 更确切地说，每个片段信息的常数时间集中。比如，当查询一个顶点周围所有的临近边时，在临近顶点的边的操作上与数量是线性的，但是每条边是常数时间。 结构之所以称为半边数据结构，是因为在这个结构中并不会存储网格的边的信息，取而代之的是半边(half-edges)。半边这么叫，就是因为它其实是一条边的一半，等于是把一条边保持长度不变，形式上分为两条半边（因为按照定义边没有宽度或者至少是单位宽度，这就是一个假象划分）。这两条半边组合在一起称为一条边，也就是一条边等于一对半边。半边是有方向的，并且一条边的一对半边有相反的方向。 这个链表既可以顺时针也可以逆时针，只要在使用中保持一致就好。环中的每半边存储一个指向以其为边的面的指针（图中没有画出来）、指向半边终点的指针（同样没画出来）和指向它的另一条半边（就是合起来组成一条边的那个半边）的指针。结构如下: 123456789struct HE_edge &#123; HE_vert* vert; // vertex at the end of the half-edge HE_edge* pair; // oppositely oriented adjacent half-edge HE_face* face; // face the half-edge borders HE_edge* next; // next half-edge around the face &#125;; 在半边数据结构中的点储存着x，y，z的位置和以其为起始点的半边的指针。在任意给定的点上存在超过一条我们可以选择的半边，但是我们只需要选择其中一条并且是哪一条没关系，在下面的查询方法中我们会看到解释。 12345678910struct HE_vert &#123; float x; float y; float z; HE_edge* edge; // one of the half-edges emantating from the vertex &#125;; 对于一个半边数据结构的简单形式，一个面仅仅需要储存一个围绕它的边的指针，在一些特定场合可能要求我们储存比如材质和法向一类的信息。和上面一样，虽然有很多边围绕着面，我们只需要储存其中一条，而无所谓是哪一条。 123456struct HE_face &#123; HE_edge* edge; // one of the half-edges bordering the face &#125;; 邻近查询关于邻近查询的大多数答案就储存在边、点和面的数据结构里。比如，围绕着半边的面或者点可以轻易地找出 12345HE_vert* vert1 = edge-&gt;vert;HE_vert* vert2 = edge-&gt;pair-&gt;vert; HE_face* face1 = edge-&gt;face;HE_face* face2 = edge-&gt;pair-&gt;face; 稍微复杂一点的例子，找到围绕着面的所有半边。因为围绕着面的所有半边形成了一个环状列表，并且面结构中储存了其中一个半边的指针。 12345HE_edge* edge = face-&gt;edge;do &#123;// do something with edge edge = edge-&gt;next;&#125; while (edge != face-&gt;edge); 类似地，我们可能对围绕着特定点的边或者是面感兴趣,如果指针组成了围绕点的一个圈,那么应该是 12345HE_edge* edge = vert-&gt;edge;do &#123;// do something with edge, edge-&gt;pair or edge-&gt;face edge = edge-&gt;pair-&gt;next;&#125; while (edge != vert-&gt;edge); 值得注意的是所有的例子中都没有检查空指针，这是因为流形曲面的限制。为此要求，所有的指针都必须是有效的。其他邻近关系都可以通过下面的这些例子被迅速找到。 练练手实现一下数据结构的定义基本的数据结构有点、边和面: 12345678910111213141516171819202122232425262728293031namespace trimesh_type &#123; //命名空间三角网格 typedef long index_t; struct point_t &#123; //顶点 index_t index; //顶点的索引 float x, y, z; //顶点的坐标 &#125;; struct edge_t &#123; //三角网格中的边 index_t v[2]; //存储两个顶点 index_t&amp; start() &#123; return v[0]; &#125; index_t&amp; end() &#123; return v[1]; &#125; edge_t() &#123; v[0] = v[1] = -1; //初始化两个顶点的索引 &#125; &#125;; struct triangle_t &#123; //三角形 point_t v[3]; //三角形三个顶点 const point_t&amp; i() const &#123; return v[0]; &#125; const point_t&amp; j() const &#123; return v[1]; &#125; const point_t&amp; k() const &#123; return v[2]; &#125; &#125;;&#125; 半边结构： 12345678910111213struct halfedge_t &#123; index_t toVertex; //半边所指向的顶点 index_t face; //半边所存储的面（若为边界，存储的面为空） index_t edge; //所在的无向边 index_t prev; //前一个半边 index_t oppositeHe; //与自己方向相反的半边 index_t nextHe; //下一条半边（逆时针方向） halfedge_t() :toVertex(-1), face(-1), edge(-1), oppositeHe(-1), nextHe(-1) &#123;&#125; &#125;; mesh中包含维护的变量有： 123456789private: vector&lt;point_t&gt; mPoints; //点集 vector&lt;triangle_t&gt; mTriangles; //三角形网格集合 vector&lt;halfedge_t&gt; mHalfEdges; //半边集合 vector&lt;index_t &gt; mVertexHalfEdges; //根据顶点索引获取半边索引 vector&lt;index_t &gt; mFaceHalfEdges; //根据面的索引获取半边索引 vector&lt;index_t &gt; mEdgeHalfEdges; //根据无向边的索引获取半边的索引 typedef map&lt;pair&lt;index_t, index_t&gt;, index_t &gt; directedEdge2indexMap_t; directedEdge2indexMap_t mDirectedEdge2heIndex; //根据有向边获取半边索引 Mesh的建立输入：想要构建模型的点集以及三角形网格的信息 输出：一个完整的mesh数据结构 但是为了方便地构建出HalfEdge的数据结构，还应该提供边的集合，边的集合可以通过点以及三角形网格的信息获取 12345678910111213141516int unorderedEdgesFromTriangles(const vector&lt;triangle_t&gt; &amp;triangles, vector&lt;edge_t&gt; &amp;edgesOut) &#123; typedef set&lt;pair&lt;index_t , index_t &gt; &gt; edgeSet_t; //边集，防止重复建边 edgeSet_t edges; for (index_t t = 0; t &lt; triangles.size(); ++t) &#123; edges.insert(make_pair(min(triangles[t].i().index, triangles[t].j().index), max(triangles[t].i().index, triangles[t].j().index))); edges.insert(make_pair(min(triangles[t].j().index, triangles[t].k().index), max(triangles[t].j().index, triangles[t].k().index))); edges.insert(make_pair(min(triangles[t].k().index, triangles[t].i().index), max(triangles[t].k().index, triangles[t].i().index))); &#125; edgesOut.resize(edges.size()); int e = 0; for (auto it = edges.begin(); it != edges.end(); it++, e++) &#123; edgesOut.at(static_cast&lt;unsigned long long int&gt;(e)).start() = it-&gt;first; edgesOut.at(static_cast&lt;unsigned long long int&gt;(e)).end() = it-&gt;second; &#125; return 0; &#125; 获取到边集信息后就可以构建mesh了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124int trimesh::trimesh_t::build(const vector&lt;point_t &gt;&amp; points, const vector&lt;edge_t&gt;&amp; edges, const vector&lt;triangle_t&gt;&amp; triangles) &#123; //有向边到面的映射 directedEdge2indexMap_t de2fi; for (int fi = 0; fi &lt; triangles.size(); ++fi) &#123; const triangle_t&amp; tri = triangles[fi]; de2fi[make_pair(tri.v[0].index, tri.v[1].index)] = fi; de2fi[make_pair(tri.v[1].index, tri.v[2].index)] = fi; de2fi[make_pair(tri.v[2].index, tri.v[0].index)] = fi; &#125; clear(); mTriangles = triangles; mPoints = points; mVertexHalfEdges.resize(points.size(), -1); mFaceHalfEdges.resize(triangles.size(), -1); mEdgeHalfEdges.resize(edges.size(), -1); //由于是半边，需要申请两倍的边空间 mHalfEdges.reserve(edges.size() * 2); for (int ei = 0; ei &lt; edges.size(); ++ei) &#123; const edge_t&amp; edge = edges[ei]; //把一条边分为两个有向的半边 const index_t he0index = mHalfEdges.size(); mHalfEdges.push_back(halfedge_t()); halfedge_t&amp; he0 = mHalfEdges.back(); const index_t he1index = mHalfEdges.size(); mHalfEdges.push_back(halfedge_t()); halfedge_t&amp; he1 = mHalfEdges.back(); //存储面 he0.face = directedEdge2faceIndex(de2fi, edge.v[0], edge.v[1]); //存储边 halfEdge（0-&gt;1）则对应的toVertex为1 he0.toVertex = edge.v[1]; //存储对应的边 he0.edge = ei; he1.face = directedEdge2faceIndex(de2fi, edge.v[1], edge.v[0]); he1.toVertex = edge.v[0]; he1.edge = ei; //存储对边 he0.oppositeHe = he1index; he1.oppositeHe = he0index; if (mDirectedEdge2heIndex.find(make_pair(edge.v[0], edge.v[1])) != mDirectedEdge2heIndex.end()) &#123; cout &lt;&lt; &quot;fail to build mesh: mDirectedEdge2heIndex.find(make_pair(edge.v[0], edge.v[1])) != mDirectedEdge2heIndex.end()&quot; &lt;&lt; endl; return -1; &#125; if (mDirectedEdge2heIndex.find(make_pair(edge.v[1], edge.v[0])) != mDirectedEdge2heIndex.end()) &#123; cout &lt;&lt; &quot;fail to build mesh: mDirectedEdge2heIndex.find(make_pair(edge.v[1], edge.v[0])) != mDirectedEdge2heIndex.end()&quot; &lt;&lt; endl; return -1; &#125; //根据有向边可以寻找到对应的halfEdge mDirectedEdge2heIndex[make_pair(edge.v[0], edge.v[1])] = he0index; mDirectedEdge2heIndex[make_pair(edge.v[1], edge.v[0])] = he1index; //如果某条边所指向的顶点的halfEdge为空或者该halfEdge所对的面为空 if(mVertexHalfEdges[he0.toVertex] == -1 || he1.face == -1) &#123; //就把当前halfEdge的对边赋值给他 mVertexHalfEdges[he0.toVertex] = he0.oppositeHe; &#125; if(mVertexHalfEdges[he1.toVertex] == -1 || he0.face == -1) &#123; mVertexHalfEdges[he1.toVertex] = he1.oppositeHe; &#125; //面对halfEdge的索引 if (he0.face != -1 &amp;&amp; mFaceHalfEdges[he0.face] == -1) &#123; mFaceHalfEdges[he0.face] = he0index; &#125; if(he1.face != -1 &amp;&amp; mFaceHalfEdges[he1.face] == -1) &#123; mFaceHalfEdges[he1.face] = he1index; &#125; if(mEdgeHalfEdges[ei] != -1) &#123; cout &lt;&lt; &quot;fail to build mesh: mEdgeHalfEdges[ei] != -1&quot; &lt;&lt; endl; return -1; &#125; mEdgeHalfEdges[ei] = he0index; &#125; vector&lt;index_t &gt; boundaryHeis; for (index_t hei = 0; hei &lt; mHalfEdges.size(); ++hei) &#123; //标记边界 halfedge_t&amp; he = mHalfEdges[hei]; if(he.face == -1) &#123; boundaryHeis.push_back(hei); continue; &#125; //不是边界就标记next const triangle_t&amp; face = triangles[he.face]; const index_t i = he.toVertex; index_t j = -1; if (face.v[0].index == i) j = face.v[1].index; else if (face.v[1].index == i) j = face.v[2].index; else if (face.v[2].index == i) j = face.v[0].index; if(j == -1) &#123; cout &lt;&lt; &quot;fail to build mesh: Caused by next halfEdge not found exception&quot; &lt;&lt; endl; return -1; &#125; he.nextHe = mDirectedEdge2heIndex[make_pair(i, j)]; &#125; //对于边界的he，将整个边界路径找到 map&lt;index_t , set&lt;index_t &gt; &gt; vertex2outgoingBoundaryHei; for (auto hei = boundaryHeis.begin(); hei != boundaryHeis.end(); hei++) &#123; //找到结点的对应边界，一个结点可能会对应多个边界he，用set存储 const index_t originatingVertex = mHalfEdges[mHalfEdges[*hei].oppositeHe].toVertex; vertex2outgoingBoundaryHei[originatingVertex].insert(*hei); &#125; //外边界逐个添加next for (auto hei = boundaryHeis.begin(); hei != boundaryHeis.end(); hei++) &#123; halfedge_t&amp; he = mHalfEdges[*hei]; set&lt;index_t &gt;&amp; outgoing = vertex2outgoingBoundaryHei[he.toVertex]; if (!outgoing.empty()) &#123; auto it = outgoing.begin(); he.nextHe = *it; outgoing.erase(it); &#125; &#125; //添加prev for (auto it = mHalfEdges.begin(); it != mHalfEdges.end(); it++) &#123; halfedge_t&amp; he = *it; he.prev = mHalfEdges[he.oppositeHe].nextHe; &#125; for (auto it = vertex2outgoingBoundaryHei.begin(); it != vertex2outgoingBoundaryHei.end(); it++) &#123; if(!it-&gt;second.empty()) &#123; cout &lt;&lt; &quot;fail to build mesh: Caused by border redundant&quot; &lt;&lt; endl; return -1; &#125; &#125; cout &lt;&lt; &quot;successfully built the mesh&quot; &lt;&lt; endl; return 0; &#125; 顶点的顶点邻居查询获取邻居的步骤： 从0结点开始 1.获取当前结点所在的半边（初始半边start）所指向的顶点（toVertex）（1号顶点），该顶点为一个邻居 2.获取当前顶点所在半边的前一个半边（prev），即先获取当前半边的opposite，再取opposite的next半边，判断该半边与start是否相同，这里显然不同，该半边所指向的顶点（toVertex）（2号顶点），该顶点为一个邻居 3.获取当前顶点所在半边的前一个半边（prev），判断该半边与start是否相同，这里显然不同，该半边所指向的顶点（toVertex）（3号顶点），该顶点为一个邻居 4.获取当前顶点所在半边的前一个半边（prev），判断该半边与start是否相同，这里显然不同，该半边所指向的顶点（toVertex）（4号顶点），该顶点为一个邻居 5.获取当前顶点所在半边的前一个半边（prev），判断该半边与start是否相同，这里显然不同，该半边所指向的顶点（toVertex）（5号顶点），该顶点为一个邻居 6.获取当前顶点所在半边的前一个半边（prev），判断该半边与start是否相同，这里显然不同，该半边所指向的顶点（toVertex）（6号顶点），该顶点为一个邻居 7.获取当前顶点所在半边的前一个半边（prev），判断该半边与start是否相同，这里发现与start相同，循环结束，输出邻居 123456789101112int vvNeighbors(const index_t vertexIndex, vector&lt;index_t &gt;&amp; result) const &#123; result.clear(); const index_t startHei = mVertexHalfEdges[vertexIndex]; //获取顶点所在的半边索引 index_t hei = startHei; while (true) &#123; const halfedge_t&amp; he = mHalfEdges[hei]; result.push_back(he.toVertex); //半边所对的结点为一个邻居 hei = he.prev; //（he.opposite.toVertex） if(hei == startHei) break; &#125; return 0; &#125; 顶点-面邻居查询查询所在顶点与哪些面相邻，实际上就是把查询顶点-顶点邻居时把顶点换为半边所对应的面 1234567891011121314int vfNeighbors(const index_t vertexIndex, vector&lt;index_t &gt;&amp; result) const &#123; result.clear(); unordered_set&lt;index_t &gt; temp; const index_t startHei = mVertexHalfEdges[vertexIndex]; index_t hei = startHei; while (true) &#123; const halfedge_t&amp; he = mHalfEdges[hei]; if(he.face != -1) temp.insert(he.face); hei = he.prev; if (hei == startHei) break; &#125; result = vector&lt;index_t &gt;(temp.begin(), temp.end()); return 0; &#125; 边-面邻居查询首先查询边是否存在，若不存在直接退出，否则返回该边正反两条半边所对的面 123456789101112131415161718192021int efNeighbors(const index_t vi, const index_t vj, vector&lt;index_t &gt;&amp; result) &#123; bool flag = false; result.clear(); if(mDirectedEdge2heIndex.find(make_pair(vi, vj)) != mDirectedEdge2heIndex.end()) &#123; if(mHalfEdges[mDirectedEdge2heIndex[make_pair(vi, vj)]].face != -1)&#123; result.push_back(mHalfEdges[mDirectedEdge2heIndex[make_pair(vi, vj)]].face); flag = true; &#125; &#125; if (mDirectedEdge2heIndex.find(make_pair(vj, vi)) != mDirectedEdge2heIndex.end()) &#123; if(mHalfEdges[mDirectedEdge2heIndex[make_pair(vj, vi)]].face != -1) &#123; result.push_back(mHalfEdges[mDirectedEdge2heIndex[make_pair(vj, vi)]].face); flag = true; &#125; &#125; if(!flag) &#123; cout &lt;&lt; &quot;this edge does not exist&quot; &lt;&lt; endl; return -1; &#125; return 0; &#125;","categories":[],"tags":[{"name":"CGAL","slug":"CGAL","permalink":"https://mzzzzzzzzz.github.io/tags/CGAL/"}]},{"title":"线段切割多边形算法","slug":"线段切割多边形算法","date":"2021-03-01T06:00:08.000Z","updated":"2021-06-02T09:16:21.346Z","comments":true,"path":"2021/03/01/线段切割多边形算法/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/03/01/%E7%BA%BF%E6%AE%B5%E5%88%87%E5%89%B2%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%AE%97%E6%B3%95/","excerpt":"一、问题：用一个线段集切割一个多边形，得到多个切割后的多边形。将其看成以点为节点的图结构，依次搜索最小的闭合区域。二、算法思路：1 所有线段求相交，得到所有点，并根据点和点之间的连接关系，得到有向图 （双向连接） 1234vector&lt;Point&gt; AllPts;//所有的交点map&lt;int,vector&lt;int&gt;&gt; Graph;//有向图，key为节点下标，value为和其相连的点","text":"一、问题：用一个线段集切割一个多边形，得到多个切割后的多边形。将其看成以点为节点的图结构，依次搜索最小的闭合区域。二、算法思路：1 所有线段求相交，得到所有点，并根据点和点之间的连接关系，得到有向图 （双向连接） 1234vector&lt;Point&gt; AllPts;//所有的交点map&lt;int,vector&lt;int&gt;&gt; Graph;//有向图，key为节点下标，value为和其相连的点 2 去掉所有悬空的线段（出度数+入度数&lt;2) 3 根据连通情况，将原始图划分为多个连通图（可用Union-Find算法） 4 以一个连通图为研究对象，其实就是求最小的闭合区域： 1234567891011121314151617181920212223242526首先寻找外轮廓，auto LeftEdgePoint = FindLeftPoint(AllPts);//找到最左点vector&lt;int&gt; OutlinePath = FindClosedPath(Graph);//以最左点为起点，寻找外轮廓，结束条件为路径包含所有线段DeletePath(Graph,OutlinePath);//查找成功后，将查找到的连通关系从连通图中删除，得到如下的关系寻找最小闭合路径，直到所有节点被删掉while(!Graph.IsEmpty())&#123; auto startPt = AllPts[Graph.First()];//找任意点为起点 vector&lt;int&gt; OutlinePath = FindClosedPath(Graph);//寻找闭合轮廓，结束条件为路径不包含任何线段 DeletePath(Graph,OutlinePath);//查找成功后，将连通关系从连通图中删除&#125;再在连通图中找到合法的闭合路径，可用回溯法vector&lt;int&gt; path;bool backTrack(int node)&#123; if(IsValidPath()) return true;//结束条件：路径闭合(nextPoint为path的起始点)，并且不包含任何其他线段 vector&lt;int&gt; links = Graph[node];//下一个节点 foreach(auto link in links)&#123;//搜索可能性 if(path.contains(link))continue;//不能回头 path.push_back(link);//尝试可能性 if(backTrack(link)) return true;//如果找到了，则返回 path.Remove(path.end());//回溯 &#125; return false;&#125; 三、CGAL库的2D arrangement方法：2D arrangement example: 12345678910111213141516171819202122#include &lt;CGAL/Cartesian.h&gt;#include &lt;CGAL/MP_Float.h&gt;#include &lt;CGAL/Quotient.h&gt;#include &lt;CGAL/Arr_segment_traits_2.h&gt;#include &lt;CGAL/Arrangement_2.h&gt;typedef CGAL::Quotient&lt;CGAL::MP_Float&gt; Number_type;typedef CGAL::Cartesian&lt;Number_type&gt; Kernel;typedef CGAL::Arr_segment_traits_2&lt;Kernel&gt; Traits_2;typedef Traits_2::Point_2 Point_2;typedef Traits_2::X_monotone_curve_2 Segment_2;typedef CGAL::Arrangement_2&lt;Traits_2&gt; Arrangement_2;int main()&#123; Arrangement_2 arr; Segment_2 cv[3]; Point_2 p1 (0, 0), p2 (0, 4), p3 (4, 0); cv[0] = Segment_2 (p1, p2); cv[1] = Segment_2 (p2, p3); cv[2] = Segment_2 (p3, p1); CGAL::insert (arr, &amp;cv[0], &amp;cv[3]); return (0);&#125; 由于CGAL库使用的是halfedge结构，所以需要一个不透水的图形，可以通过’is_isolated’属性来判断然后再对其中的hole进行遍历 12345678910111213141516171819202122232425262728293031323334353637383940void print_neighboring_vertices (Arrangement_2::Vertex_const_handle v)&#123; if (v-&gt;is_isolated()) &#123; std::cout &lt;&lt; &quot;The vertex (&quot; &lt;&lt; v-&gt;point() &lt;&lt; &quot;) is isolated&quot; &lt;&lt; std::endl; return; &#125; Arrangement_2::Halfedge_around_vertex_const_circulator first, curr; first = curr = v-&gt;incident_halfedges(); std::cout &lt;&lt; &quot;The neighbors of the vertex (&quot; &lt;&lt; v-&gt;point() &lt;&lt; &quot;) are:&quot;; do &#123; // Note that the current halfedge is directed from u to v: Arrangement_2::Vertex_const_handle u = curr-&gt;source(); std::cout &lt;&lt; &quot; (&quot; &lt;&lt; u-&gt;point() &lt;&lt; &quot;)&quot;; &#125; while (++curr != first); std::cout &lt;&lt; std::endl;&#125;void print_face (Arrangement_2::Face_const_handle f)&#123; // Print the outer boundary. if (f-&gt;is_unbounded()) std::cout &lt;&lt; &quot;Unbounded face. &quot; &lt;&lt; std::endl; else &#123; std::cout &lt;&lt; &quot;Outer boundary: &quot;; print_ccb (f-&gt;outer_ccb()); &#125; // Print the boundary of each of the holes. Arrangement_2::Hole_const_iterator hi; int index = 1; for (hi = f-&gt;holes_begin(); hi != f-&gt;holes_end(); ++hi, ++index) &#123; std::cout &lt;&lt; &quot; Hole #&quot; &lt;&lt; index &lt;&lt; &quot;: &quot;; print_ccb (*hi); &#125; // Print the isolated vertices. Arrangement_2::Isolated_vertex_const_iterator iv; for (iv = f-&gt;isolated_vertices_begin(), index = 1; iv != f-&gt;isolated_vertices_end(); ++iv, ++index)&#123; std::cout &lt;&lt; &quot; Isolated vertex #&quot; &lt;&lt; index &lt;&lt; &quot;: &quot; &lt;&lt; &quot;(&quot; &lt;&lt; iv-&gt;point() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; &#125;","categories":[],"tags":[{"name":"CGAL","slug":"CGAL","permalink":"https://mzzzzzzzzz.github.io/tags/CGAL/"}]},{"title":"LeetCode-分隔链表","slug":"LeetCode-分隔链表","date":"2021-02-28T05:38:52.000Z","updated":"2021-06-02T09:16:21.359Z","comments":true,"path":"2021/02/28/LeetCode-分隔链表/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/28/LeetCode-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/","excerpt":"题目给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5","text":"题目给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题1.创建两个虚拟头结点存储两个链表2.遍历链表分别将两个链表节点放到两个链表中3.连接两个链表 12345678910111213141516171819202122class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode dummyHead1 = new ListNode(0); ListNode dummyHead2 = new ListNode(0); dummyHead1.next = head; ListNode node1 = dummyHead1; ListNode node2 = dummyHead2; while (head != null)&#123; if (head.val &gt;= x) &#123; node2.next = head; node2 = node2.next; &#125; else &#123; node1.next = head; node1 = node1.next; &#125; head = head.next; &#125; node1.next = dummyHead2.next; node2.next = null; return dummyHead1.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-单词搜索","slug":"LeetCode-单词搜索","date":"2021-02-27T04:35:56.000Z","updated":"2021-06-02T09:16:21.361Z","comments":true,"path":"2021/02/27/LeetCode-单词搜索/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/27/LeetCode-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/","excerpt":"题目给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;], [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;], [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false.","text":"题目给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;], [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;], [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 解题递归 + 回溯 / 深度优先搜索 12345678910111213141516171819202122232425262728293031323334class Solution &#123; private int[][] move = &#123;&#123;0, 1&#125;, &#123;1,0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; public boolean exist(char[][] board, String word) &#123; if (board == null) &#123; return false; &#125; char[] words = word.toCharArray(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[i].length; j++) &#123; if (find(board, i, j, words, 0)) &#123; return true; &#125; &#125; &#125; return false; &#125; private boolean find(char[][] board, int row, int col, char[] word, int index)&#123; if (index == word.length) &#123; return true; &#125; if (row &gt;= board.length || col &gt;= board[0].length || row &lt; 0 || col &lt; 0 || board[row][col] != word[index]) &#123; return false; &#125; char temp = board[row][col]; board[row][col] = &#x27;0&#x27;; boolean exist = find(board, row + move[0][0], col + move[0][1], word, index + 1) || find(board, row + move[1][0], col + move[1][1], word, index + 1) || find(board, row + move[2][0], col + move[2][1], word, index + 1) || find(board, row + move[3][0], col + move[3][1], word, index + 1); board[row][col] = temp; return exist; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-合并两个有序数组","slug":"LeetCode-合并两个有序数组","date":"2021-02-26T05:56:46.000Z","updated":"2021-06-02T09:16:21.362Z","comments":true,"path":"2021/02/26/LeetCode-合并两个有序数组/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/26/LeetCode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 1234输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6]","text":"题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 1234输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 解题对两个数组进行一次归并即可, 为了避免元素被覆盖, 从后向前进行归并就可以解决问题. 123456789101112131415161718192021class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int index = m + n -1; while(m &gt; 0 || n &gt; 0)&#123; if(n == 0)&#123; return; &#125; else if(m == 0)&#123; nums1[index] = nums2[n - 1]; n--; &#125; else if(nums1[m-1] &gt; nums2[n-1])&#123; nums1[index] = nums1[m - 1]; m--; &#125; else &#123; nums1[index] = nums2[n - 1]; n--; &#125; index--; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-复原IP地址","slug":"LeetCode-复原IP地址","date":"2021-02-25T04:44:15.000Z","updated":"2021-06-02T09:16:21.364Z","comments":true,"path":"2021/02/25/LeetCode-复原IP地址/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/25/LeetCode-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/","excerpt":"题目给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 12输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]","text":"题目给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 12输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 解题递归 + 回溯 简单来说, 就是ip的每一段分别取1位, 2位, 3位, 分别穷举之后的字符, 并判断每部分是否为有效的ip. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (null == s || s.length() &lt; 4) &#123; return result; &#125; restoreValidIp(s, 1, 0, &quot;&quot;); return result; &#125; private void restoreValidIp(String s, int part, int start, String temp)&#123; int length = s.length(); if (start &gt;= length) &#123; return; &#125; if (part == 4) &#123; if (isValid(s.substring(start))) &#123; result.add(temp + s.substring(start)); &#125; return; &#125; else &#123; String partStr; for (int i = 1; i &lt;= 3 &amp;&amp; start + i &lt; length ; i++) &#123; partStr = s.substring(start, start + i); if (isValid(partStr)) &#123; restoreValidIp(s, part + 1, start + i, temp + partStr + &quot;.&quot; ); &#125; &#125; &#125; &#125; private boolean isValid(String partIp)&#123; if (partIp.length() &gt; 3) &#123; return false; &#125; if (partIp.startsWith(&quot;0&quot;)) &#123; return &quot;0&quot;.equals(partIp); &#125; else &#123; return Integer.valueOf(partIp) &lt;= 255; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-子集","slug":"LeetCode-子集","date":"2021-02-24T05:11:15.000Z","updated":"2021-06-02T09:16:21.365Z","comments":true,"path":"2021/02/24/LeetCode-子集/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/24/LeetCode-%E5%AD%90%E9%9B%86/","excerpt":"题目给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]","text":"题目给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题递归 + 回溯(空集也是一个子集) 12345678910111213141516171819202122class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; if (nums == null) &#123; return result; &#125; findSubset(nums, 0, new ArrayList&lt;&gt;()); result.add(new ArrayList&lt;&gt;()); return result; &#125; private void findSubset(int[] nums, int index, List&lt;Integer&gt; temp) &#123; if (index &gt;= nums.length) &#123; return; &#125; for (int i = index; i &lt; nums.length; i++) &#123; temp.add(nums[i]); result.add(new ArrayList&lt;&gt;(temp)); findSubset(nums, i + 1, temp); temp.remove(temp.size() - 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-最小覆盖子串","slug":"LeetCode-最小覆盖子串","date":"2021-02-23T14:31:23.000Z","updated":"2021-06-02T09:16:21.371Z","comments":true,"path":"2021/02/23/LeetCode-最小覆盖子串/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/23/LeetCode-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","excerpt":"题目给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。 示例： 12345输入: S = “ADOBECODEBANC”, T = “ABC”输出: “BANC”说明：如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。","text":"题目给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。 示例： 12345输入: S = “ADOBECODEBANC”, T = “ABC”输出: “BANC”说明：如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。 解题滑动窗口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String minWindow(String s, String t) &#123; int resultLeft = 0, resultRight = -1; int minLength = s.length() + 1; int left = 0, right = -1; int count = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] charc = t.toCharArray(); for (char aChar : charc) &#123; map.put(aChar, map.containsKey(aChar) ? map.get(aChar) + 1 : 1); &#125; char[] chars = s.toCharArray(); while (right &lt; s.length() &amp;&amp; left &lt; s.length())&#123; if (count == t.length())&#123; if (minLength &gt; right - left)&#123; minLength = right - left; resultLeft = left; resultRight = right; &#125; if (map.containsKey(chars[left]))&#123; if (map.get(chars[left]) == 0)&#123; count--; &#125; map.put(chars[left], map.get(chars[left]) + 1); &#125; left++; &#125; else &#123; right++; if (right &gt;= s.length()) &#123; break; &#125; if (map.containsKey(chars[right]))&#123; if (map.get(chars[right]) &gt; 0) &#123; count++; &#125; map.put(chars[right], map.get(chars[right]) - 1); &#125; &#125; &#125; if(resultLeft == 0 &amp;&amp; resultRight == -1)&#123; return &quot;&quot;; &#125; return s.substring(resultLeft, resultRight + 1); &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-相同的树","slug":"LeetCode-相同的树","date":"2021-02-22T13:50:32.000Z","updated":"2021-06-02T09:16:21.377Z","comments":true,"path":"2021/02/22/LeetCode-相同的树/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/22/LeetCode-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","excerpt":"题目给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false","text":"题目给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解题递归 1234567891011121314151617class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null || q == null) &#123; if (p == q) &#123; return true; &#125; return false; &#125; else &#123; if (p.val != q.val) &#123; return false; &#125; boolean leftIsEqual = isSameTree(p.left, q.left); boolean rightIsEqual = isSameTree(p.right, q.right); return leftIsEqual &amp;&amp; rightIsEqual; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-组合","slug":"LeetCode-组合","date":"2021-02-21T04:33:06.000Z","updated":"2021-06-02T09:16:21.379Z","comments":true,"path":"2021/02/21/LeetCode-组合/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/21/LeetCode-%E7%BB%84%E5%90%88/","excerpt":"题目给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]","text":"题目给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题递归 + 回溯 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (n &lt; 1 || n &lt; k) &#123; return result; &#125; combine(n, k, 1, new ArrayList&lt;&gt;()); return result; &#125; private void combine(int n, int k, int index, List&lt;Integer&gt; temp) &#123; if (k == 0) &#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for (int i = index; i &lt;= n - k + 1; i++) &#123; temp.add(i); combine(n, k - 1, i + 1, temp); temp.remove(temp.size() - 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-解码方法","slug":"LeetCode-解码方法","date":"2021-02-20T06:32:23.000Z","updated":"2021-06-02T09:16:21.382Z","comments":true,"path":"2021/02/20/LeetCode-解码方法/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/20/LeetCode-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/","excerpt":"题目一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&#x27;A&#x27; -&gt; 1&#x27;B&#x27; -&gt; 2...&#x27;Z&#x27; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。","text":"题目一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&#x27;A&#x27; -&gt; 1&#x27;B&#x27; -&gt; 2...&#x27;Z&#x27; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 解题动态规划(从后向前) 123456789101112131415161718192021class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int[] result = new int[n + 1]; char[] chars = s.toCharArray(); result[n] = 1; if (chars[n - 1] != &#x27;0&#x27;)&#123; result[n - 1] = 1; &#125; for (int i = n - 2; i &gt;= 0; i--) &#123; if (chars[i] != &#x27;0&#x27;) &#123; if (Integer.parseInt(s.substring(i, i + 2)) &lt;= 26) &#123; result[i] = result[i + 1] + result[i + 2]; &#125; else &#123; result[i] = result[i + 1]; &#125; &#125; &#125; return result[0]; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-验证二叉搜索树","slug":"LeetCode-验证二叉搜索树","date":"2021-02-19T04:48:28.000Z","updated":"2021-06-02T09:16:21.383Z","comments":true,"path":"2021/02/19/LeetCode-验证二叉搜索树/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/19/LeetCode-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"题目假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1: 12345输入: 2 / \\ 1 3输出: true 示例2: 123456789输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。","text":"题目假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1: 12345输入: 2 / \\ 1 3输出: true 示例2: 123456789输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题利用二叉树的中序遍历是有序的特性来判断 123456789101112131415class Solution &#123; long last = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (isValidBST(root.left)) &#123; if (last &lt; root.val) &#123; last = root.val; return isValidBST(root.right); &#125; &#125; return false; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode中二叉树遍历问题","slug":"LeetCode中二叉树遍历问题","date":"2021-02-17T14:45:51.000Z","updated":"2021-06-02T09:16:21.385Z","comments":true,"path":"2021/02/17/LeetCode中二叉树遍历问题/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/17/LeetCode%E4%B8%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/","excerpt":"题目给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？","text":"题目给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题干脆一起写了吧前序： 12345678910111213141516class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); preorderTraversal(root, result); return result; &#125; private void preorderTraversal(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) &#123; return; &#125; result.add(root.val); preorderTraversal(root.left, result); preorderTraversal(root.right, result); &#125;&#125; 中序： 123456789101112131415class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorderTraversal(root, result); return result; &#125; private void inorderTraversal(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) &#123; return; &#125; inorderTraversal(root.left, result); result.add(root.val); inorderTraversal(root.right, result); &#125;&#125; 后序: 123456789101112131415class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); postorderTraversal(root, result); return result; &#125; private void postorderTraversal(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) &#123; return; &#125; postorderTraversal(root.left, result); postorderTraversal(root.right, result); result.add(root.val); &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-75. 颜色分类","slug":"LeetCode-75. 颜色分类","date":"2021-02-09T04:29:14.000Z","updated":"2021-06-02T09:16:21.351Z","comments":true,"path":"2021/02/09/LeetCode-75. 颜色分类/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/09/LeetCode-75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","excerpt":"题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶：1.一个直观的解决方案是使用计数排序的两趟扫描算法。2.首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。3.你能想出一个仅使用常数空间的一趟扫描算法吗？","text":"题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶：1.一个直观的解决方案是使用计数排序的两趟扫描算法。2.首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。3.你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题1.可以以1为标定点, 进行一次三路快排即可2.或者使用计数排序, 分别统计0, 1, 2出现的次数, 然后按照每个元素出现的次数写入到数组中即可3.双指针,比较好实现=&gt; 1234567891011121314151617181920212223242526class Solution &#123; public void sortColors(int[] nums) &#123; int l = -1; int r = nums.length; int i = 0; while(i &lt; r)&#123; if(nums[i] == 0)&#123; l++; nums[l] = 0; if(l != i)&#123; nums[i] = 1; &#125; i++; &#125; else if(nums[i] == 1)&#123; i++; &#125; else &#123; r--; nums[i] = nums[r]; nums[r] = 2; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-爬楼梯","slug":"LeetCode-爬楼梯","date":"2021-02-08T04:26:56.000Z","updated":"2021-06-02T09:16:21.374Z","comments":true,"path":"2021/02/08/LeetCode-爬楼梯/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/08/LeetCode-%E7%88%AC%E6%A5%BC%E6%A2%AF/","excerpt":"题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶","text":"题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题其实这是一个典型的动态规划的问题, 先求出f(1), f(2), 然后根据表达式f(n) = f(n - 1) + f(n - 2)可以依次求出f(n), f(n)就是这题的解, 代码如下: 1234567891011121314151617181920class Solution &#123; int[] stairs; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; stairs = new int[n + 1]; stairs[1] = 1; stairs[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; stairs[i] = stairs[i - 1] + stairs[i - 2]; &#125; return stairs[n]; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"Windows下CGAL安装","slug":"Windows下CGAL安装","date":"2021-02-07T07:52:25.000Z","updated":"2021-06-02T09:16:21.345Z","comments":true,"path":"2021/02/07/Windows下CGAL安装/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/07/Windows%E4%B8%8BCGAL%E5%AE%89%E8%A3%85/","excerpt":"参考原文地址：http://www.cgal.org/download/windows.html ,整理如下 最近需要安装CGAL，由于依赖的库比较多，安装起来较为麻烦，在网络上参考了许多教程但是总是不得要领；最后还是依照官网上的方法进行了安装，原始步骤大致翻译如下： 首先需知： 1、下载并安装CMake 2、下载CGAL安装软件 3、需要了解如何在win7环境下设置和修改系统环境 4、只有当你需要运行CGAL测试程序时，才有必要安装Qt5；同理，只有当你需要运行三维的CGAL测试程序时，才有必要安装libQGLViewer 5、注意选择的VS控制台版本号，注意是32位还是64位。","text":"参考原文地址：http://www.cgal.org/download/windows.html ,整理如下 最近需要安装CGAL，由于依赖的库比较多，安装起来较为麻烦，在网络上参考了许多教程但是总是不得要领；最后还是依照官网上的方法进行了安装，原始步骤大致翻译如下： 首先需知： 1、下载并安装CMake 2、下载CGAL安装软件 3、需要了解如何在win7环境下设置和修改系统环境 4、只有当你需要运行CGAL测试程序时，才有必要安装Qt5；同理，只有当你需要运行三维的CGAL测试程序时，才有必要安装libQGLViewer 5、注意选择的VS控制台版本号，注意是32位还是64位。 编译的步骤如下： 1、Boost 2、Qt5 3、libQGLViewer 4、CGAL 编译Boost1.打开Visual Studio 命令提示窗口 2.进入D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/boost_1_44_0/tools/jam/src 3.执行 build.bat 会在D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/boost_1_44_0 /tools/jam/src/bin.ntx86 生成 bjam.exe文件. 4.Copy bjam.exe 文件到 D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/boost_1_44_0 下 6.进入D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/boost_1_44_0 目录 7.执行bjam.exe 编译命令，如下： 123456789101112131415(1)编译所有boost动态库 （release|debug），包括头文件和库文件bjam --toolset=msvc-9.0 --prefix=D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/output --without-python --build-type=complete link=shared threading=multi install(2)只编译 release 版本 regex 动态库，包括头文件和库文件bjam --toolset=msvc-9.0 --prefix=D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/output1 --with-regex link=shared threading=multi variant=release runtime-link=shared install(3)只编译 release 版本 regex 动态库，包括库文件bjam --toolset=msvc-9.0--stagedir=D:/05_Computer/04_3rdPatry/02Boost/boost_1_44_0/output2--with-regex link=shared threading=multi variant=release runtime-link=shared stage 编译好Boost后，需要设置两个环境变量如下（具体路径由Boost所在路径为准），并且将bin路径添加到系统环境Path中： 12BOOST_LIBRARYDIR=C:\\dev\\libboost_1_59_0\\libBOOST_INCLUDEDIR=C:\\dev\\libboost_1_59_0 安装Qt5Qt5的安装很简单，直接到官网下载合适的版本，安装好后只需要将bin路径添加到系统环境中就可以了。 安装libQGLViewer下载libQGLViewer,并解压到某一目录下示例如下： 1I extract the sources in C:\\dev, a new directory is created C:\\dev\\libQGLViewer-2.6. 启动Vs的控制台，并cd到libQGLViewer所在的路径，执行以下命令： 12qmake.exenmake 最后将生成的release和debug路径都添加到系统Path中，并设置： 1QGLVIEWERROOT to C:\\dev\\libQGLViewer-2.6.3 安装CGAL打开CGAL软件并安装，选择32bit解压到一个目录； 打开CMake选择source路径和binary路径，点击Configure和Generate后，会得到一个CGAL.sln 使用VS2010打开CGAL.sln选择ALL_BUILD分别在Debug和Release情况下编译 最后将生成的Bin目录添加到Path中。 Note:注意将C:\\thirdParty\\cgal\\auxiliary\\gmp\\lib添加到系统Path中。","categories":[],"tags":[{"name":"CGAL","slug":"CGAL","permalink":"https://mzzzzzzzzz.github.io/tags/CGAL/"}]},{"title":"LeetCode-旋转链表","slug":"LeetCode-旋转链表","date":"2021-02-06T13:21:03.000Z","updated":"2021-06-02T09:16:21.368Z","comments":true,"path":"2021/02/06/LeetCode-旋转链表/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/06/LeetCode-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"题目给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL","text":"题目给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解题说是旋转, 其实就是将链表分割成两部分, 然后重新组合起来即可 123456789101112131415161718192021222324252627282930313233class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || head.next == null)&#123; return head; &#125; ListNode cur = head; int length = 0; while (cur != null) &#123; cur = cur.next; length ++; &#125; k = k % length; if(k == 0) &#123; return head; &#125; ListNode first = head; ListNode second = head; for (int i = 0; i &lt; k; i++) &#123; first = first.next; &#125; while (first != null)&#123; if (first.next == null)&#123; break; &#125; first = first.next; second = second.next; &#125; ListNode newHead = second.next; second.next = null; first.next = head; return newHead; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-最小路径和","slug":"LeetCode-最小路径和","date":"2021-02-06T05:25:10.000Z","updated":"2021-06-02T09:16:21.372Z","comments":true,"path":"2021/02/06/LeetCode-最小路径和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/06/LeetCode-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"题目给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。","text":"题目给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题记忆化搜索 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int[][] memo; public int minPathSum(int[][] grid) &#123; if (grid == null || grid.length &lt; 1) &#123; return 0; &#125; int m = grid.length; int n = grid[0].length; initMemo(m, n); return minPathSum(grid, 0, 0); &#125; private int minPathSum(int[][] grid, int x, int y) &#123; if (x &gt;= grid.length || y &gt;= grid[0].length) &#123; return 0; &#125; if (memo[x][y] != 0) &#123; return memo[x][y]; &#125; int right = 0; if (x == grid.length - 1 &amp;&amp; y == grid[0].length - 1) &#123; memo[x][y] = grid[x][y]; &#125; else if (x == grid.length - 1) &#123; memo[x][y] = grid[x][y] + minPathSum(grid, x, y + 1); &#125; else if (y == grid[0].length - 1) &#123; memo[x][y] = grid[x][y] + minPathSum(grid, x + 1, y); &#125; else &#123; memo[x][y] = grid[x][y] + Math.min(minPathSum(grid, x + 1, y), minPathSum(grid, x, y + 1)); &#125; return memo[x][y]; &#125; private void initMemo(int m, int n) &#123; memo = new int[m][n]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = new int[n]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-不同路径","slug":"LeetCode-不同路径","date":"2021-02-05T04:23:09.000Z","updated":"2021-06-02T09:16:21.354Z","comments":true,"path":"2021/02/05/LeetCode-不同路径/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/05/LeetCode-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","excerpt":"题目一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28","text":"题目一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 解题1.动态规划2.最下方和最右侧点, 路径均为13.节点{x, y}到终点的路径数等于下方和右侧的路径数之和=&gt;所以动态规划的状态转移方程为 : f(x,y) = f(x + 1, y) + f(x, y + 1) 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m &lt; 1 || n &lt; 1) &#123; return 0; &#125; int[][] result = new int[m][n]; Arrays.fill(result, new int[n]); Arrays.fill(result[m - 1], 1); result[m - 1][n - 1] = 1; for (int i = m - 2; i &gt;= 0; i--) &#123; result[i][n - 1] = 1; for (int j = n - 2; j &gt;= 0; j--) &#123; result[i][j] = result[i][j + 1] + result[i + 1][j]; &#125; &#125; return result[0][0]; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-最大子序和","slug":"LeetCode-最大子序和","date":"2021-02-04T13:19:58.000Z","updated":"2021-06-02T09:16:21.370Z","comments":true,"path":"2021/02/04/LeetCode-最大子序和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/04/LeetCode-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","excerpt":"题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。","text":"题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解题可以使用滑动窗口 123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = nums[0]; int sum = 0; for (int num : nums) &#123; if (sum &gt; 0) &#123; sum += num; &#125; else &#123; sum = num; &#125; res = Math.max(res, sum); &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-字母异位词分组","slug":"LeetCode-字母异位词分组","date":"2021-02-02T06:18:24.000Z","updated":"2021-06-02T09:16:21.366Z","comments":true,"path":"2021/02/02/LeetCode-字母异位词分组/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/02/LeetCode-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","excerpt":"题目给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明：1.所有输入均为小写字母。2.不考虑答案输出的顺序。","text":"题目给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明：1.所有输入均为小写字母。2.不考虑答案输出的顺序。 解题对每个字符串转换成字符数组进行排序, 排序后的字符串作为key, 原始的异位词作为value存储到List中, 代码如下: 1234567891011121314class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; char[] chars = str.toCharArray(); Arrays.sort(chars); String key = new String(chars); List&lt;String&gt; group = map.getOrDefault(key, new ArrayList&lt;&gt;()); group.add(str); map.put(key, group); &#125; return new ArrayList&lt;&gt;(map.values()); &#125;&#125;","categories":[],"tags":[]},{"title":"LeetCode-全排列","slug":"LeetCode-全排列","date":"2021-02-01T04:16:18.000Z","updated":"2021-06-02T09:16:21.358Z","comments":true,"path":"2021/02/01/LeetCode-全排列/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/02/01/LeetCode-%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"题目给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]","text":"题目给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题递归 + 回溯 123456789101112131415161718192021222324252627class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return result; &#125; permute(nums, new ArrayList&lt;&gt;(), new boolean[nums.length]); return result; &#125; private void permute(int[] nums, List&lt;Integer&gt; temp, boolean[] used) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (temp.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; if (!used[i]) &#123; temp.add(nums[i]); used[i] = true; permute(nums, temp, used); temp.remove(temp.size() - 1); used[i] = false; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-组合总和 II","slug":"LeetCode-组合总和 II","date":"2021-01-31T05:14:10.000Z","updated":"2021-06-02T09:16:21.380Z","comments":true,"path":"2021/01/31/LeetCode-组合总和 II/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/31/LeetCode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/","excerpt":"题目给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]]","text":"题目给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 解题先排序，再递归 + 回溯 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; if (candidates == null || candidates.length &lt; 1 || target &lt; 0) &#123; return result; &#125; Arrays.sort(candidates); findTarget(candidates, target, 0, new ArrayList&lt;&gt;()); return result; &#125; private void findTarget(int[] candidates, int target, int index, List&lt;Integer&gt; temp) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for (int i = index; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123; if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1])&#123; continue; &#125; temp.add(candidates[i]); findTarget(candidates, target - candidates[i], i + 1, temp); temp.remove(temp.size() - 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-移除元素","slug":"LeetCode-移除元素","date":"2021-01-30T05:22:58.000Z","updated":"2021-06-02T09:16:21.378Z","comments":true,"path":"2021/01/30/LeetCode-移除元素/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/30/LeetCode-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 123给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。","text":"题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 123给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 解题1.对整个数组进行一次快速排序中的partition操作即可, 将数组分为等于val和不等于val的两部分2.设定[0,l]区间所有元素均不等于val,[l+1,i)区间元素等于val, l初始化化为-1, i初始化为0, 初始状态两个条件都满足设定3.遍历数组, 在遍历的过程中保持[0,l],[l+1,i)两个区间的特性 123456789101112131415161718192021class Solution &#123; public int removeElement(int[] nums, int val) &#123; // 其实就是根据快速排序的方式进行一次partition操作即可, 只是把元素分为不等于val和等于val的两部分 // 设定[0,l]区间所有元素均不等于val,[l+1,i)区间元素等于val, l初始化化为-1, i初始化为0, 初始状态两个条件都满足设定 // 遍历数组,进行partition操作 int l = -1; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != val)&#123; // i==l+1时不需要交换位置,只需要l++即可, 否则l+1和i交换位置保障[0,l],[l+1,i)两个区间的特性 if(i != l + 1)&#123; int temp = nums[l + 1]; nums[l + 1] = nums[i]; nums[i] = temp; &#125; l++; &#125; &#125; return l + 1; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-组合总和","slug":"LeetCode-组合总和","date":"2021-01-30T05:12:17.000Z","updated":"2021-06-02T09:16:21.381Z","comments":true,"path":"2021/01/30/LeetCode-组合总和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/30/LeetCode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","excerpt":"题目给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]]","text":"题目给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解题递归 + 回溯 1234567891011121314151617181920212223class Solution39 &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (candidates == null || candidates.length &lt; 1 || target &lt; 0) &#123; return result; &#125; Arrays.sort(candidates); findTarget(candidates, target, 0, new ArrayList&lt;&gt;()); return result; &#125; private void findTarget(int[] candidates, int target, int index, List&lt;Integer&gt; temp)&#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(temp)); return; &#125; for (int i = index; i &lt; candidates.length &amp;&amp; candidates[i] &lt;= target; i++) &#123; temp.add(candidates[i]); findTarget(candidates, target - candidates[i], i, temp); temp.remove(temp.size() - 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-删除排序数组中的重复项","slug":"LeetCode-删除排序数组中的重复项","date":"2021-01-29T05:28:47.000Z","updated":"2021-06-02T09:16:21.360Z","comments":true,"path":"2021/01/29/LeetCode-删除排序数组中的重复项/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/29/LeetCode-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例1 : 123给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例2 : 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。","text":"题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例1 : 123给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例2 : 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 解题定义两个变量分别记录不重复的元素位置, 和要遍历的元素位置, 如果不是重复元素就依次移动即可 123456789101112131415class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length &lt; 2) return nums.length; // [0...i]区间不包含重复元素, nums[i] == nums[j] int i = 0, j = 1; for(; j &lt; nums.length; j++)&#123; if(nums[j] != nums[i])&#123; nums[i + 1] = nums[j]; i++; &#125; &#125; return i + 1; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-搜索插入位置","slug":"LeetCode-搜索插入位置","date":"2021-01-29T04:09:42.000Z","updated":"2021-06-02T09:16:21.367Z","comments":true,"path":"2021/01/29/LeetCode-搜索插入位置/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/29/LeetCode-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4","text":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 解题最简单的办法, 就是遍历一遍, 时间复杂度, 最优O(1), 最差O(n), 代码如下: 123456789class Solution &#123; public int searchInsert(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) if (nums[i] &gt;= target) return i; return nums.length; &#125; &#125; 因为是有序数组, 所以可以使用二分搜索来处理, 在数据量较大的情况下, 二分搜索的效率更高, 时间复杂度是O(logn), LeetCode给的测试用例数据量都不大, 所以二分搜索的性能并不高于直接遍历的方法, 代码如下: 1234567891011121314151617181920212223242526class Solution35 &#123; public int searchInsert(int[] nums, int target) &#123; int index = findIndex(nums, 0, nums.length - 1, target); return index; &#125; private int findIndex(int[] nums, int left, int right, int target)&#123; if(target &gt; nums[right])&#123; return right + 1; &#125; if(target &lt; nums[left])&#123; return left; &#125; if(right == left)&#123; return right; &#125; int mid = (right - left + 1) / 2 + left; if(target == nums[mid])&#123; return mid; &#125; else if (target &gt; nums[mid])&#123; return findIndex(nums, mid + 1, right, target); &#125; else &#123; return findIndex(nums, left, mid - 1, target); &#125; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-k个一组翻转链表","slug":"LeetCode-k个一组翻转链表","date":"2021-01-28T05:44:00.000Z","updated":"2021-06-02T09:16:21.352Z","comments":true,"path":"2021/01/28/LeetCode-k个一组翻转链表/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/28/LeetCode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。","text":"题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题1.使用递归算法2.每k个一组进行翻转, 同时将翻转后的最后一个节点指向下一组k个的头结点3.翻转之前需要先校验一次是否有k个节点, 是否需要进行翻转4.递归方法返回翻转后的头结点 123456789101112131415161718192021222324252627282930class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (k &lt; 2) &#123; return head; &#125; return reverse(head, k); &#125; private ListNode reverse(ListNode head, int k) &#123; ListNode cur = head; for (int i = 0; i &lt; k; i++) &#123; if (cur == null) &#123; return head; &#125; else &#123; cur = cur.next; &#125; &#125; ListNode nextReverse = cur; ListNode pre = null; cur = head; ListNode next; for (int i = 0; i &lt; k; i++) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; head.next = reverse(nextReverse, k); return pre; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-两两交换链表中的节点","slug":"LeetCode-两两交换链表中的节点","date":"2021-01-27T05:51:19.000Z","updated":"2021-06-02T09:16:21.355Z","comments":true,"path":"2021/01/27/LeetCode-两两交换链表中的节点/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/27/LeetCode-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。","text":"题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 1.你的算法只能使用常数的额外空间。2.你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题设置两个指针, 当前节点cur和下一个节点next, 每次交换cur和next即可 1234567891011121314151617181920212223242526class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode dummyHead = new ListNode(0); ListNode pre = dummyHead; // 每次cur和next交换位置 ListNode cur = head; ListNode next = head.next; while (cur != null &amp;&amp; next != null) &#123; // 交换cur 和next cur.next = next.next; next.next = cur; pre.next = next; // 移动pre, cur, next pre = cur; cur = cur.next; if (cur == null)&#123; break; &#125; next = cur.next; &#125; return dummyHead.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-四数之和","slug":"LeetCode-四数之和","date":"2021-01-26T05:33:08.000Z","updated":"2021-06-02T09:16:21.363Z","comments":true,"path":"2021/01/26/LeetCode-四数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/26/LeetCode-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例： 1234567给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]","text":"题目给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例： 1234567给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题先排序后计算, 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) &#123; return res; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; if (nums[i] * 4 &gt; target) &#123; break; &#125; if (nums[i] + 3 * nums[nums.length - 1] &lt; target) &#123; continue; &#125; for (int j = i + 1; j &lt; nums.length - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; if (nums[j] * 3 &gt; target - nums[i]) &#123; break; &#125; if (nums[j] + 2 * nums[nums.length - 1] &lt; target - nums[i]) &#123; continue; &#125; int begin = j + 1; int end = nums.length - 1; while (begin &lt; end) &#123; int sum = nums[i] + nums[j] + nums[begin] + nums[end]; if (sum == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[begin], nums[end])); while (begin &lt; end &amp;&amp; nums[begin] == nums[begin + 1]) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; nums[end] == nums[end - 1]) &#123; end--; &#125; begin++; end--; &#125; else if (sum &lt; target) &#123; begin++; &#125; else &#123; end--; &#125; &#125; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-电话号码的字母组合","slug":"LeetCode-电话号码的字母组合","date":"2021-01-25T05:40:12.000Z","updated":"2021-06-02T09:16:21.375Z","comments":true,"path":"2021/01/25/LeetCode-电话号码的字母组合/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/25/LeetCode-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。","text":"题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题字典 + 递归 + 回溯 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; private static char[][] NUM_CHAR = new char[][]&#123; null, null, &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;, &#123;&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;, &#123;&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;&#125;, &#123;&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;&#125;, &#123;&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;&#125;, &#123;&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;&#125;, &#123;&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;&#125;, &#123;&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125; &#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || &quot;&quot;.equals(digits)) &#123; return result; &#125; letterCombinations(digits, 0, &quot;&quot;); return result; &#125; private void letterCombinations(String digits, int index, String temp)&#123; if (index &gt; digits.length()) &#123; return; &#125; char[] chars = NUM_CHAR[Integer.parseInt(digits.substring(index, index + 1))]; if (index == digits.length() - 1) &#123; for (char aChar : chars) &#123; result.add(temp + aChar); &#125; &#125; else &#123; for (char aChar : chars) &#123; letterCombinations(digits, index + 1, temp + aChar); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-最接近的三数之和","slug":"LeetCode-最接近的三数之和","date":"2021-01-24T05:46:55.000Z","updated":"2021-06-02T09:16:21.373Z","comments":true,"path":"2021/01/24/LeetCode-最接近的三数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/24/LeetCode-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 12例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).","text":"题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 12例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题先排序, 后计算,双指针, 滑动窗口 123456789101112131415161718192021222324252627class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; // 排序 Arrays.sort(nums); int closestNum = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int l = i + 1, r = nums.length - 1; while (l &lt; r)&#123; int threeSum = nums[l] + nums[r] + nums[i]; if (Math.abs(threeSum - target) &lt; Math.abs(closestNum - target)) &#123; closestNum = threeSum; &#125; if (threeSum &gt; target) &#123; r--; &#125; else if (threeSum &lt; target) &#123; l++; &#125; else &#123; return target; &#125; &#125; &#125; return closestNum; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-三数之和","slug":"LeetCode-三数之和","date":"2021-01-24T05:45:44.000Z","updated":"2021-06-02T09:16:21.353Z","comments":true,"path":"2021/01/24/LeetCode-三数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/24/LeetCode-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： 12345[[-1, 0, 1],[-1, -1, 2]]","text":"题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： 12345[[-1, 0, 1],[-1, -1, 2]] 解题12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; // 跳过可能重复的答案 int l = i + 1, r = nums.length - 1, sum = 0 - nums[i]; while (l &lt; r) &#123; if (nums[l] + nums[r] == sum) &#123; ls.add(Arrays.asList(nums[i], nums[l], nums[r])); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) &#123; l++; &#125; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) &#123; r--; &#125; l++; r--; &#125; else if (nums[l] + nums[r] &lt; sum) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) &#123; l++; // 跳过重复值 &#125; l++; &#125; else &#123; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) &#123; r--; &#125; r--; &#125; &#125; &#125; &#125; return ls; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-盛最多水的容器","slug":"LeetCode-盛最多水的容器","date":"2021-01-23T05:43:16.000Z","updated":"2021-06-02T09:16:21.376Z","comments":true,"path":"2021/01/23/LeetCode-盛最多水的容器/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/23/LeetCode-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例 12输入: [1,8,6,2,5,4,8,3,7]输出: 49","text":"题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题方法一 : 暴力破解, 双层循环, 可能会超时, 时间复杂度O(n²)方法二 : 对撞指针, 代码如下 12345678910111213141516class Solution &#123; public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while(left &lt; right)&#123; if(height[left] &lt; height[right])&#123; maxArea = Math.max(maxArea, height[left] * (right - left)); left++; &#125; else &#123; maxArea = Math.max(maxArea, height[right] * (right - left)); right--; &#125; &#125; return maxArea; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-无重复字符的最长子串","slug":"LeetCode-无重复字符的最长子串","date":"2021-01-22T13:32:42.000Z","updated":"2021-06-02T09:16:21.369Z","comments":true,"path":"2021/01/22/LeetCode-无重复字符的最长子串/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/22/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 123输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 123输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。","text":"题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 123输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 123输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。 方法使用滑动窗口解答, 判断字符是不是重复, 使用字符数组来判断 设定l,r两个指针, 首先移动指针r直到出现重复字符,这个时候只可能有一个字符重复, 然后再移动字符l, 如果已经不包含重复字符了, 如果移除的字符是已经出现过的字符, 则表示此时[l…r]之间已经没有重复字符了 重复上面整个步骤, 完成整改遍历过程即可, 遍历过程中记录r - l + 1的最大值, 具体代码如下:123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; char[] freq = new char[256]; int l = 0, r = -1; int max = 0; while (l &lt; s.length())&#123; if (r == s.length() - 1)&#123; break; &#125; if (freq[s.charAt(r + 1)] == 0)&#123; freq[s.charAt(r + 1)]++; r++; max = Math.max(max, r - l + 1); &#125; else &#123; freq[s.charAt(l)]--; l++; &#125; &#125; return max; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-两数相加","slug":"LeetCode-两数相加","date":"2021-01-21T13:28:42.000Z","updated":"2021-06-02T09:16:21.357Z","comments":true,"path":"2021/01/21/LeetCode-两数相加/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/21/LeetCode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","text":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解法方法：把每一位相加, 记录进位, 代码如下 1234567891011121314151617181920212223242526class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode list1 = l1, list2 = l2, cur = dummyHead; int carry = 0; int sum = 0; while (list1 != null || list2 != null )&#123; sum = carry; if (list1 != null) &#123; sum += list1.val; list1 = list1.next; &#125; if (list2 != null) &#123; sum += list2.val; list2 = list2.next; &#125; carry = sum / 10; cur.next = new ListNode(sum % 10); cur = cur.next; &#125; if (carry == 1) &#123; cur.next = new ListNode(1); &#125; return dummyHead.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"LeetCode-两数之和","slug":"LeetCode-两数之和","date":"2021-01-20T13:30:29.000Z","updated":"2021-06-02T09:16:21.356Z","comments":true,"path":"2021/01/20/LeetCode-两数之和/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/20/LeetCode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]","text":"题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法方法1：直接每次从头到尾比较 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] a = new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; a[0] = i; a[1] = j; //return new int[] &#123;i,j&#125;; &#125; &#125; &#125; return a; &#125;&#125; 方法2：两次for循环（两遍hashmap） 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] b = new int[2]; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; map.put(nums[i],i); &#125; for(int j=0;j&lt;nums.length;j++)&#123; int a = target - nums[j]; if(map.containsKey(a) &amp;&amp; j!=map.get(a))&#123; b[0] = j; b[1] = map.get(a); return b; //return new int[] &#123;j,map.get(a)&#125;; &#125; &#125; return b; &#125;&#125; 方法3：一次for循环（一次hashmap） 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; return new int[] &#123;map.get(nums[i]),i&#125;; &#125; map.put(target-nums[i],i); &#125; return new int[]&#123;1,1,1&#125;; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"}]},{"title":"Hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。","slug":"Hexo添加各种功能","date":"2021-01-18T05:17:49.000Z","updated":"2021-06-02T09:16:21.350Z","comments":true,"path":"2021/01/18/Hexo添加各种功能/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/18/Hexo%E6%B7%BB%E5%8A%A0%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD/","excerpt":"hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。 本文参考了: visugar.com这里面说的很详细了。 1. SEO优化推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。 1SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 百度seo刚建站的时候是没有搜索引擎收录我们的网站的。可以在搜索引擎中输入’site:&lt;域名&gt;’来查看一下。 1. 登录百度站长平台添加网站登录百度站长平台，在站点管理中添加你自己的网站。","text":"hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。 本文参考了: visugar.com这里面说的很详细了。 1. SEO优化推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。 1SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 百度seo刚建站的时候是没有搜索引擎收录我们的网站的。可以在搜索引擎中输入’site:&lt;域名&gt;’来查看一下。 1. 登录百度站长平台添加网站登录百度站长平台，在站点管理中添加你自己的网站。 验证网站有三种方式：文件验证、HTML标签验证、CNAME验证。 第三种方式最简单，只要将它提供给你的那个xxxxx使用CNAME解析到xxx.baidu.com就可以了。也就是登录你的阿里云，把这个解析填进去就OK了。 2. 提交链接我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎 12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 这时候你需要在你的根目录下’config.xml’中看看url有没有改成你自己的;重新部署后，就可以在public文件夹下看到生成的sitemap.xml和baidusitemap.xml了。 然后就可以向百度提交你的站点地图了。 这里建议使用自动提交。自动提交又分为三种：主动推送、自动推送、sitemap。 可以三个一起提交不要紧，我选择的是后两种。 自动推送:把百度生成的自动推送代码，放在主题文件/layout/common/head.ejs的适当位置，然后验证一下就可以了。 sitemap:把两个sitemap地址，提交上去，看到状态正常就OK了。ps: 百度收录比较慢，慢慢等个十天半个月再去’site:&lt;域名&gt;’看看有没有被收录。 google的SEO流程一样，google更简单，而且收录更快，进入google站点地图，提交网站和sitemap.xml，就可以了。 如果你这个域名在google这里出了问题，那你就提交 yourname.github.io，这个链接，效果是一样的。 不出意外的话一天内google就能收录你的网站了。 其他的搜索，如搜狗搜索，360搜索，流程是一样的，这里就不再赘述。 2. 评论系统评论系统有很多，但是很多都是墙外的用不了，之前说过这个valine好像集成在hueman和next主题里面了，但是我还没有研究过，我看的是visugar这个博主用的来比力评论系统，感觉也还不错。来比力官网，注册好后，点击管理页面，在代码管理中找到安装代码： 获取安装代码后，在主题的comment下新建一个文件放入刚刚那段代码，再找到article文件，找到如下代码，若没有则直接在footer后面添加即可。livebe即为刚刚所创文件名称。 1&lt;%- partial(&#x27;comment/livebe&#x27;) %&gt; 然后可以自己设置一些东西：还可以设置评论提醒，这样别人评论你的时候就可以及时知道了。 3. 添加百度统计百度统计可以在后台上看到你网站的访问数，浏览量，浏览链接分布等很重要的信息。所以添加百度统计能更有效的让你掌握你的网站情况。 百度统计，注册一下，这里的账号好像和百度账号不是一起的。照样把代码复制到head.ejs文件中，然后再进行一下安装检查，半小时左右就可以在百度统计里面看到自己的网站信息了。 4. 文章阅读量统计leanCloudleanCloud，进去后注册一下，进入后创建一个应用：在存储中创建Class，命名为Counter,然后在设置页面看到你的应用Key，在主题的配置文件中： 1234leancloud_visitors: enable: true app_id: 你的id app_key: 你的key 在article.ejs中适当的位置添加如下，这要看你让文章的阅读量统计显示在哪个地方了， 1阅读数量:&lt;span id=&quot;&lt;%= url_for(post.path) %&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&lt;%- post.title %&gt;&quot;&gt;&lt;/s&gt; 然后在footer.ejs的最后，添加： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script src=&quot;//cdn1.lncld.net/static/js/2.5.0/av-min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var APP_ID = &#x27;你的app id&#x27;; var APP_KEY = &#x27;你的app key&#x27;; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); // 显示次数 function showTime(Counter) &#123; var query = new AV.Query(&quot;Counter&quot;); if($(&quot;.leancloud_visitors&quot;).length &gt; 0)&#123; var url = $(&quot;.leancloud_visitors&quot;).attr(&#x27;id&#x27;).trim(); // where field query.equalTo(&quot;words&quot;, url); // count query.count().then(function (number) &#123; // There are number instances of MyClass where words equals url. $(document.getElementById(url)).text(number? number : &#x27;--&#x27;); &#125;, function (error) &#123; // error is an instance of AVError. &#125;); &#125; &#125; // 追加pv function addCount(Counter) &#123; var url = $(&quot;.leancloud_visitors&quot;).length &gt; 0 ? $(&quot;.leancloud_visitors&quot;).attr(&#x27;id&#x27;).trim() : &#x27;icafebolger.com&#x27;; var Counter = AV.Object.extend(&quot;Counter&quot;); var query = new Counter; query.save(&#123; words: url &#125;).then(function (object) &#123; &#125;) &#125; $(function () &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); addCount(Counter); showTime(Counter); &#125;);&lt;/script&gt; 重新部署后就可以了。 5. 引入不蒜子访问量和访问人次统计不蒜子的添加非常非常方便，不蒜子 在footer.ejs中的合适位置，看你要显示在哪个地方，添加： 1234&lt;!--这一段是不蒜子的访问量统计代码--&gt;&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp; &lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 就可以了。","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo博客配置RSS插件","slug":"Hexo博客配置RSS插件","date":"2021-01-17T07:49:21.000Z","updated":"2021-06-02T05:30:15.139Z","comments":true,"path":"2021/01/17/Hexo博客配置RSS插件/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/17/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AERSS%E6%8F%92%E4%BB%B6/","excerpt":"1、安装rss插件 在站点根目录下安装 1npm install hexo-generator-feed","text":"1、安装rss插件 在站点根目录下安装 1npm install hexo-generator-feed 2、配置_config.yml文件，启用插件12345678# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 3、在hexo-theme-yilia-plus主题添加RSS订阅配置(可以跳过此步骤) theme-yilia-plus 12# RSS订阅rss: /atom.xml 4、生成RSS订阅文件1hexo g","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mzzzzzzzzz.github.io/tags/Hexo/"}]},{"title":"Hexo博客添加helper-live2d动态模型插件","slug":"Hexo博客添加helper-live2d动态模型插件","date":"2021-01-16T08:35:44.000Z","updated":"2021-06-02T05:30:15.137Z","comments":true,"path":"2021/01/16/Hexo博客添加helper-live2d动态模型插件/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/16/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0helper-live2d%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%8F%92%E4%BB%B6/","excerpt":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 插件的github地址hexo-helper-live2d live2d模型仓库 必须有Node环境 ➡️ Linux下安装node和npm","text":"Tips:前导必备 博主博客地址 博主使用的是**hexo-theme-yilia-plus**主题 插件的github地址hexo-helper-live2d live2d模型仓库 必须有Node环境 ➡️ Linux下安装node和npm 1、安装模块&#160;&#160;&#160;&#160;在hexo根目录执行命令 1# npm install --save hexo-helper-live2d 2、下载模型&#160;&#160;&#160;&#160;作者各种模型包展示 ➡️ hexo live2d插件 2.0 ! live2d模型仓库 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 使用npm install &#123;packagename&#125;安装模型 12---笔者使用的模型# npm install live2d-widget-model-nico 3、详细配置在Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.参阅 live2d-widget.js API 博主配置文件示例12345678910111213141516171819202122232425262728293031# Live2D## https://github.com/EYHN/hexo-helper-live2d## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: enable: true #enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-hibiki # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 145 height: 315 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo编译文档时JS或HTML混乱解决方案","slug":"Hexo编译文档时JS或HTML混乱解决方案","date":"2021-01-16T03:26:51.000Z","updated":"2021-06-02T05:30:15.140Z","comments":true,"path":"2021/01/16/Hexo编译文档时JS或HTML混乱解决方案/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/16/Hexo%E7%BC%96%E8%AF%91%E6%96%87%E6%A1%A3%E6%97%B6JS%E6%88%96HTML%E6%B7%B7%E4%B9%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"原因 之前为在 GitHub 博客上写自己的 html 网页，在 hexo 根目录下的 source 文件夹中放了自己的 js 文件，每次 hexo g 后，pubic 文件夹中的 js 文件就混乱了，与自己实际 js 不一致。 解决方案(跳过 hexo 渲染) Hexo 3.0 以上支持修改 Hexo 主目录下的 config.yml 配置文件中的 skip_render 参数。","text":"原因 之前为在 GitHub 博客上写自己的 html 网页，在 hexo 根目录下的 source 文件夹中放了自己的 js 文件，每次 hexo g 后，pubic 文件夹中的 js 文件就混乱了，与自己实际 js 不一致。 解决方案(跳过 hexo 渲染) Hexo 3.0 以上支持修改 Hexo 主目录下的 config.yml 配置文件中的 skip_render 参数。 1234567891011skip_render: &quot;test.html&quot; # source 文件夹下指定文件skip_render: test/* # 单个文件夹下全部文件skip_render: test/*.md # 单个文件夹下指定类型文件skip_render: test/** # 单个文件夹下全部文件及子文件skip_render: # 多个文件夹以及其他情况 - test/* - test/*.html 博主自己的配置如下 1234567891011121314# 跳过 hexo 渲染skip_render: - anires/** - assets/** - gitment/** - baidu_sitepush/** - canvas_nest/** - docs/** - &#x27;baidu_verify_QzGNSJ7F59.html&#x27; - &#x27;*.html&#x27; - &#x27;*.js&#x27; - README.md - &#x27;*.sh&#x27; - &#x27;*.txt&#x27; 注：若修改配置后不见效果，先执行 hexo clean 后再执行 hexo g 重新编译","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"关于npm install失败的解决方法","slug":"关于npm-install失败的解决方法","date":"2021-01-16T01:33:15.000Z","updated":"2021-06-02T08:13:22.185Z","comments":true,"path":"2021/01/16/关于npm-install失败的解决方法/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/16/%E5%85%B3%E4%BA%8Enpm-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"可以尝试以下解决方案 1.授权执行1sudo npm install 2.运行高权限用户1sudo npm install --unsafe-perm","text":"可以尝试以下解决方案 1.授权执行1sudo npm install 2.运行高权限用户1sudo npm install --unsafe-perm 3.安装某个模块1sudo npm i 模块名 --unsafe-perms 4.清除代理1npm config set proxy false 5.清除缓存1npm cache clean","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo更换主题","slug":"hexo更换主题","date":"2021-01-15T09:23:00.000Z","updated":"2021-06-02T05:10:03.012Z","comments":true,"path":"2021/01/15/hexo更换主题/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/15/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/","excerpt":"hexo更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里这里有200多个主题可以选。不过最受欢迎的就是那么几个，比如NexT主题，非常的简洁好看，大多数人都选择这个，关于这个的教程也比较多。不过我选择的是yilias-plus这个主题.不管怎么样，至少是符合我个人的审美。","text":"hexo更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里这里有200多个主题可以选。不过最受欢迎的就是那么几个，比如NexT主题，非常的简洁好看，大多数人都选择这个，关于这个的教程也比较多。不过我选择的是yilias-plus这个主题.不管怎么样，至少是符合我个人的审美。 使用yilias-plus1、安装12cd ./themes/git clone --depth=1 https://github.com/JoeyBling/hexo-theme-yilia-plus.git ./yilia-plus 2、配置修改hexo根目录下的 ‘config.yml’ -&gt; ‘theme: yilia-plus’ 3、更新12cd themes/yilia-plusgit pull 4、配置主题配置文件在主目录下的’config.yml’，请根据自己需要修改使用。完整配置Demo例子，可以参考yilia-plus博客备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283# Header-菜单menu: 主页: / 技术笔记: https://zhousiwei.gitee.io/ibooks/ 随笔: /tags/随笔/# subNav-子导航subNav: github: &quot;#&quot; gitee: &quot;#&quot; # 码云 jianshu: &quot;#&quot; #简书 cnblog: &quot;#&quot; #blog: &quot;#&quot; #csdn: &quot;#&quot; #rss: &quot;#&quot; #zhihu: &quot;#&quot; #qq: &quot;img/2434387555.jpg&quot; #weixin: &quot;img/weixin_.png&quot; #weibo: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:zhousiwei0911@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;# 悬停预览图片效果hover_effect: ## `global` 0: Set separately, 1: Enable global 2: Close global ## `global` 0: 分开设置, 1: 全局启用, 2: 全局关闭 global: 2 # SubNav-导航 subNav: true# RSS订阅(关于如何配置启用:https://www.jianshu.com/p/2aaac7a19736)rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 / 设为 /blog/。root: /# Content# 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &#x27;展开全文&#x27;# 数学公式mathjax: false# Open link in a new tab | 是否在新窗口打开链接open_in_new: article: true # 文章链接 menu: true # 导航菜单 subNav: true # 子菜单# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &#x27;谢谢你请我吃糖果&#x27;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/weixin.png# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &#x27;目录，不存在的…&#x27;# 是否有快速回到顶部的按钮top: true# Miscellaneous# 百度统计baidu_analytics: &#x27;&#x27;google_analytics: &#x27;&#x27;# 网站图标favicon: /favicon.ico# 你的头像urlavatar: /img/head.jpg# 是否开启分享share_jia: true# 评论：1、畅言；2、Disqus；3、Gitment；4、Giteement# 不需要使用某项，直接设置值为false，或注释掉# 具体请参考wiki：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki# 1、畅言changyan_appid: falsechangyan_conf: false# 2、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia-plus的disqus: false# 3、Gitment----基于GitHub的评论系统(关闭请设置gitment_owner为false)# 关于如何集成:https://www.jianshu.com/p/ac7658cc912fgitment_owner: false #你的 GitHub ID# 是否使用官方js(false可以提升访问速度，本地修改过一部分的js，官方js可能会出现服务器不稳定，不太建议使用)gitment_remote: falsegitment_repo: &#x27;&#x27; #存储评论的 repo name(需要在Github创建)gitment_oauth: client_id: &#x27;&#x27; #client ID client_secret: &#x27;&#x27; #client secret# 4、Giteement----【国内用户建议使用这个，相对比较快】# 关于如何集成:https://www.jianshu.com/p/f5c4633524c7# 基于码云的评论系统(https://gitee.com/zhousiwei/giteement)giteement: enable: false # 是否启用码云评论系统 # 是否使用官方js(false可以提升访问速度) remote: false redirect_uri: &#x27;&#x27; # 应用回调地址(请和配置的第三方应用保持一致) # 不能更改(网上开源项目`https://github.com/Rob--W/cors-anywhere`作者提供的专门用来跨域服务器的配置) oauth_uri: https://cors-anywhere.herokuapp.com/https://gitee.com/oauth/token giteeID: &#x27;&#x27; # 你的码云账号英文名 # 存储评论的 repo name(需要在码云仓库创建公开仓库) repo: &#x27;&#x27; gitment_oauth: client_id: &#x27;&#x27; #client ID client_secret: &#x27;&#x27; #client secret# 访问量统计功能(不蒜子)busuanzi: enable: true site_visit: true # 站点访问量显示 article_visit: true # 文章访问量显示# 网易云音乐插件music: enable: false # 播放器尺寸类型(1：长尺寸、2：短尺寸) type: 2 #id: 1332647902 # 网易云分享的音乐ID(更换音乐请更改此配置项) autoPlay: true # 是否开启自动播放 # 提示文本(关闭请设置为false) text: &#x27;这似乎是首纯音乐，请尽情的欣赏它吧！&#x27;# 页面点击小红心clickLove: # (关闭请设置为false) enable: true# GitHub Ribbons(https://github.blog/2008-12-19-github-ribbons/)github: # (关闭请设置为false) url: https://github.com/JoeyBling/hexo-theme-yilia-plus# 页脚 Litten(此配置项已弃用)# 帮助我们让更多人可以更方便使用Hexo，请尽量不要修改此主题配置pageFooter: litten: GitHub:&lt;a href=&quot;https://github.com/JoeyBling/hexo-theme-yilia-plus&quot; target=&quot;_blank&quot;&gt;hexo-theme-yilia-plus&lt;/a&gt;# 开启百度站长平台自动推送(https://ziyuan.baidu.com/linksubmit/index)baidu_push: false# 版权声明# 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明copyright_type: 2# 网站成立年份(默认为 2018，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)since: 2018# Progress Bar | 页面加载进度条# Demo: http://github.hubspot.com/pace/docs/welcome/# type: barber-shop|big-counter|bounce|center-atom|center-circle|# center-radar|center-simple|corner-indicator|flash|flat-top|# loading-bar|mac-osx|minimal# color: black|blue|green|orange|pink|purple|red|silver|white|yellow|progressBar: enable: false type: &#x27;minimal&#x27; # Keep Quotes | 保留引号避免出错(某些type会导致样式重叠排版错误) color: blue# Apple Touch icon 苹果图标(关闭请设置为false)apple_touch_icon: &#x27;/apple-touch-icon-180x180.png&#x27;# Tab Title Change | 标签页标题切换tab_title_change: enable: true left_tab_title: &#x27;(つェ⊂) 我藏好了哦~ &#x27; return_tab_title: &#x27;(*´∇｀*) 被你发现啦~ &#x27;# https://github.com/willin/hexo-wordcount# 是否开启字数统计(关闭请设置enable为false)# 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计word_count: enable: true # 只在文章详情显示(不在首页显示) only_article_visit: true# 文字输入特效# https://github.com/disjukr/activate-power-modeactivate_power_mode: enable: true # 使输入模式丰富多彩 colorful: true # 是否开启摇动 shake: false# 飘雪特效# https://github.com/MlgmXyysd/snow.jssnow: false# 看板娘动态模型插件## https://github.com/JoeyBling/live2d-widget.jslive2d: # (关闭请设置为false) enable: false # 模型名称(取值请参考：https://github.com/JoeyBling/hexo-theme-yilia-plus/wiki/live2d%E6%A8%A1%E5%9E%8B%E5%8C%85%E5%B1%95%E7%A4%BA) model: hibiki display: position: right # 显示位置：left/right(default: &#x27;right&#x27;) width: 145 # 模型的长度(default: 150) height: 315 # 模型的高度(default: 300) hOffset: 50 # 水平偏移(default: 0) #vOffset: -20 # 垂直偏移(default: -20) mobile: show: false # 是否在移动设备上显示(default: true) scale: 0.6 # 移动设备上的缩放(default: 0.5) react: opacity: 0.8 # 模型透明度(default: 0.7)# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 # header: &#x27;#D3D1DC&#x27; header: &#x27;#4d4d4d&#x27; gif: # 是否启用左侧边栏动态图效果 enable: false # 自定义背景图路径(默认可以不设置，提供默认背景图) # path: /img/biubiubiu.gif # 右滑板块背景 slider: &#x27;linear-gradient(200deg,#a0cfe4,#e8c37e)&#x27;# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &#x27;所有文章&#x27; friends: &#x27;友链&#x27; aboutme: &#x27;关于我&#x27;# 友情链接friends: 技术笔记: #网站名称 #网站地址 url: https://zhousiwei.gitee.io/ibooks/ #网站图片(可忽略不写) img: https://zhousiwei.gitee.io/ibooks/favicon.ico #网站简介(可忽略不写) description: 记录工作和学习过程中的笔记：Java、前端开发、Hexo博客、聚合支付、Linux笔记、ElasticSearch、ELK日志分析 GitHub: url: https://github.com/JoeyBling 码云: url: https://gitee.com/zhousiwei 简书: url: https://www.jianshu.com/u/02cbf31a043a CSDN: url: https://blog.csdn.net/qq_30930805# 关于我aboutme: 主要涉及技术：&lt;br&gt;Java后端开发、聚合支付、&lt;br&gt;公众号开发、开源爱好者、Linux&lt;br&gt;&lt;br&gt;联系QQ:2434387555&lt;br&gt;&lt;br&gt;很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo的基本配置","slug":"hexo的基本配置","date":"2021-01-14T04:31:22.000Z","updated":"2021-06-02T05:10:03.013Z","comments":true,"path":"2021/01/14/hexo的基本配置/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/14/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","excerpt":"hexo的基本配置hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。","text":"hexo的基本配置hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。 其中，’description’主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。’author’参数用于主题显示文章的作者。 网址 参数 描述 url 网址 root 网站根目录 permalink 文章的永久链接格式 permalink_defaults 永久链接中各部分的默认值 在这里，你需要把’url’改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫’temp.md’，那么这个时候他自动生成的地址就是’http://yoursite.com/2021/01/14/temp&#39;。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找。 参数 描述 :year/:month/:day/:title/ 2013/07/14/hello-world :year-:month-:day-:title.html 2013-07-14-hello-world.html :category/:title foo/bar/hello-world 再往下翻，中间这些都默认就好了。 1234567theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] ‘theme’就是选择什么主题，也就是在’theme’这个文件夹下，在官网上有很多个主题，默认给你安装的是’lanscape’这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在’theme’文件夹下，再修改这个参数就可以了。 接下来这个’deploy’就是网站的部署的，’repo’就是仓库(Repository)的简写。’branch’选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 ‘—‘ 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 下是预先定义的参数，您可在模板中使用这些参数值并加以利用。| 参数 | 描述 || :—-: | :—-: || layout | 布局 || title | 标题 || date | 建立日期 || updated | 更新日期 || comments | 开启文章的评论功能 || tags | 标签（不适用于分页） || categories | 分类（不适用于分页） || permalink | 覆盖文章网址 | 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 ‘Foo, Bar’ 不等于 ‘Bar, Foo’；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games layout（布局)当你每一次使用代码 1hexo new paper 它其实默认使用的是’post’这个布局，也就是在’source’文件夹下的’post’里面。 Hexo 有三种默认布局：’post’、’page’ 和 ‘draft’，它们分别对应不同的路径，而您自定义的其他布局和 ‘post’ 相同，都将储存到 ‘source/posts’ 文件夹。| 布局 | 路径 || :—-: | :—-: || post | source/posts || page | source || draft | source/drafts |而new这个命令其实是： 1hexo new [layout] &lt;title&gt; 只不过这个layout默认是post罢了。 ###page如果你想另起一页，那么可以使用 1hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是’http://xxx.xxx/board&#39; ###draftdraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source/draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]},{"title":"Hexo搭建","slug":"hexo搭建","date":"2021-01-13T12:18:15.000Z","updated":"2021-06-02T05:09:57.475Z","comments":true,"path":"2021/01/13/hexo搭建/","link":"","permalink":"https://mzzzzzzzzz.github.io/2021/01/13/hexo%E6%90%AD%E5%BB%BA/","excerpt":"选择Hexo的原因现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。","text":"选择Hexo的原因现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用 git --version 来查看一下版本 2. 安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3. 安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init myblog 这个myblog可以自己取什么名字都行，然后 12cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件12hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。注册完登录后，在GitHub.com中看到一个New repository，新建仓库创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。点击create repository。5.生成SSH添加到GitHub回到你的git bash中，12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。可以用以下两条，检查一下你有没有输对12git config user.namegit config user.email 然后创建SSH,一路回车1ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。在gitbash中，查看是否成功1ssh -T git@github.com 6. 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。1npm install hexo-deployer-git --save 然后123hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写注意deploy时可能要你输入username和password。","categories":[],"tags":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"}]}],"categories":[],"tags":[{"name":"3D vision","slug":"3D-vision","permalink":"https://mzzzzzzzzz.github.io/tags/3D-vision/"},{"name":"java","slug":"java","permalink":"https://mzzzzzzzzz.github.io/tags/java/"},{"name":"CGAL","slug":"CGAL","permalink":"https://mzzzzzzzzz.github.io/tags/CGAL/"},{"name":"leetcode","slug":"leetcode","permalink":"https://mzzzzzzzzz.github.io/tags/leetcode/"},{"name":"搭建blog","slug":"搭建blog","permalink":"https://mzzzzzzzzz.github.io/tags/%E6%90%AD%E5%BB%BAblog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://mzzzzzzzzz.github.io/tags/Hexo/"}]}